import { join } from 'path';
import resolve from 'resolve';
import esbuildEsm from 'esbuild';
import NodeModulesPolyfills from '@esbuild-plugins/node-modules-polyfill';
import { logger } from '@lwrjs/diagnostics';
// https://github.com/evanw/esbuild/issues/706
// Fixed in 0.11.0 but upgrading past 0.9.7 has caused breaking changes for consumers...
// https://github.com/salesforce-experience-platform-emu/lwr/issues/1014
let esbuild = esbuildEsm;
if (!esbuildEsm) {
    try {
        esbuild = require('esbuild');
    }
    catch {
        /* this is to support mjs/cjs dual impl */
    }
}
const NodePolyfillsPlugin = NodeModulesPolyfills.default || NodeModulesPolyfills;
const ExternalsPlugin = function ({ external }) {
    return {
        name: 'replace-extension-plugin',
        setup(build) {
            build.onResolve({ filter: /.*/ }, ({ path, importer }) => {
                if (importer && external && external.includes(path)) {
                    return { path, external: true };
                }
            });
        },
    };
};
// Helper function using an iterative approach to resolve export entries.
function resolveExportsIteratively(entry, preferred = ['import', 'module', 'default', 'browser']) {
    let current = entry;
    // Loop until we reach a string or cannot go further.
    while (current && typeof current === 'object') {
        let found = false;
        for (const condition of preferred) {
            if (current[condition] !== undefined) {
                current = current[condition];
                found = true;
                break;
            }
        }
        if (!found)
            break;
    }
    return typeof current === 'string' ? current : undefined;
}
export async function resolveNpmModuleSpecifierBlock(specifier, dest, config) {
    let res;
    try {
        let pkgVersion;
        try {
            res = resolve.sync(specifier, {
                packageFilter: function (pkg) {
                    const { exports, browser } = pkg;
                    // 1. Handle the "exports" field (and nested conditions)
                    if (exports && exports['.']) {
                        const resolved = resolveExportsIteratively(exports['.']);
                        if (resolved) {
                            pkg.main = resolved;
                        }
                    }
                    // 2. Fall back to the "browser" field (if it's a string)
                    else if (browser && typeof browser === 'string') {
                        pkg.main = browser;
                    }
                    // 3. Next check the "module" field.
                    else if (pkg.module) {
                        pkg.main = pkg.module;
                    }
                    // 4. If we have an alternate browser mapping for this entry point, use it
                    // Exmaple:
                    //  {
                    //     "main": "./node-cjs.js",
                    //     "module": "./node-esm.js",
                    //     "browser": {
                    //       "./node-cjs.js": "./browser-cjs.js",
                    //       "./node-esm.js": "./browser-esm.js"
                    //     }
                    //  }
                    if (browser &&
                        typeof browser === 'object' &&
                        typeof pkg.main === 'string' &&
                        browser[pkg.main]) {
                        pkg.main = browser[pkg.main];
                    }
                    // Grab package.json version (if set) before we go.
                    if (pkg.version) {
                        pkgVersion = pkg.version;
                    }
                    return pkg;
                },
            });
        }
        catch (error) {
            // Just return undefined for module not found.
            if (error.code === 'MODULE_NOT_FOUND') {
                logger.debug({
                    label: 'npm-module-provider',
                    message: `Failed to resolve ${specifier} from npm`,
                    additionalInfo: { cause: error },
                });
                return undefined;
            }
            throw error;
        }
        if (!res) {
            return undefined;
        }
        // Ensure package version is set.
        if (pkgVersion === undefined) {
            throw new Error('Failed to find version in package.json');
        }
        const outfile = join(dest, specifier, '_bundle.js');
        const cacheKey = `${specifier}@${pkgVersion}`;
        await esbuild.build({
            entryPoints: [res],
            format: 'esm',
            bundle: true,
            write: true,
            platform: 'browser',
            mainFields: ['browser', 'module', 'main'],
            outfile: outfile,
            define: {
                'process.env.NODE_ENV': JSON.stringify('production'),
            },
            plugins: [ExternalsPlugin(config), NodePolyfillsPlugin()],
        });
        return {
            id: cacheKey,
            entry: outfile,
            specifier,
            version: pkgVersion,
        };
    }
    catch (err) {
        logger.error(`[npm-module-provider][esbuild] resolveNpmModules: ${specifier} ${dest}`, { res, err });
    }
}
class Queue {
    queue = [];
    workingOnPromise = false;
    pendingPromise = false;
    enqueue(promise) {
        return new Promise((resolve, reject) => {
            this.queue.push({ promise, resolve, reject });
            this.dequeue();
        });
    }
    dequeue() {
        if (this.workingOnPromise) {
            return false;
        }
        const item = this.queue.shift();
        if (!item) {
            return false;
        }
        this.workingOnPromise = true;
        try {
            item.promise()
                .then((value) => {
                this.workingOnPromise = false;
                item.resolve(value);
                this.dequeue();
            })
                .catch((err) => {
                this.workingOnPromise = false;
                item.reject(err);
                this.dequeue();
            });
        }
        catch (err) {
            this.workingOnPromise = false;
            item.reject(err);
            this.dequeue();
        }
        return true;
    }
}
const RESOLVER_QUEUE = new Queue();
export async function resolveNpmModuleSpecifier(specifier, dest, config) {
    return RESOLVER_QUEUE.enqueue(resolveNpmModuleSpecifierBlock.bind(null, specifier, dest, config));
}
//# sourceMappingURL=resolveNpmModules.js.map