import { logger } from '@lwrjs/diagnostics';
import { VERSION_SIGIL, explodeSpecifier, getSpecifier, isExternalSpecifier, isLambdaEnv, normalizeFromFileURL, } from '@lwrjs/shared-utils';
import path from 'path';
import fs from 'fs-extra';
import { LRUCache } from 'lru-cache';
import { getSiteBundleId, parseSiteId, resolveStaticBundleVersion } from '../site-metadata.js';
import { cacheCountStore } from '@lwrjs/instrumentation';
import { getTracer, BundleSpan } from '@lwrjs/instrumentation';
const BUNDLE_SOURCE_NOT_FOUND = 'Bundle Source Path Not Found';
export default class StaticBundleProvider {
    name = 'static-bundle-provider';
    codeCache;
    siteRootDir;
    bundleConfig;
    i18n;
    siteMetadata;
    bundleCacheSize;
    constructor(config, context) {
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.siteMetadata = context.siteMetadata;
        this.siteRootDir = context.siteMetadata.getSiteRootDir();
        this.bundleConfig = context.config.bundleConfig;
        this.i18n = context.config.i18n;
        this.bundleCacheSize =
            config.bundleCacheSize ?? parseInt(process.env.BUNDLE_CODE_CACHE_SIZE ?? '500', 10);
        if (this.bundleCacheSize > 0) {
            this.codeCache = new LRUCache({
                max: this.bundleCacheSize,
                dispose: (_value, key) => {
                    if (isLambdaEnv()) {
                        logger.warn(`Bundle Code evicted from cache ${key}`);
                    }
                    else {
                        logger.verbose(`Bundle Code evicted from cache ${key}`);
                    }
                },
            });
        }
    }
    async bundle(moduleId, runtimeEnvironment, runtimeParams) {
        const { specifier, version } = moduleId;
        const { i18n: { defaultLocale }, } = runtimeEnvironment;
        const localeId = (runtimeParams?.locale || defaultLocale);
        const ssr = runtimeParams?.ssr;
        let debug = runtimeEnvironment.debug;
        let metadata = this.getBundleMetadata({ moduleId, localeId, debug, ssr });
        if (!metadata && debug) {
            // Fallback to use prod bundles if the debug variant does not exist
            // eg: debug bundles are not shipped to the Lambda
            // eg: locally, an MRT bundle may or may not have debug metadata, depending on how it's generated
            metadata = this.getBundleMetadata({ moduleId, localeId, debug: false, ssr });
            if (metadata)
                debug = false;
        }
        if (!metadata && isExternalSpecifier(moduleId.specifier, this.bundleConfig)) {
            const { specifier: unversionedSepcifier } = explodeSpecifier(moduleId.specifier);
            metadata = {
                path: this.bundleConfig?.external?.[unversionedSepcifier],
                imports: [],
                dynamicImports: [],
                version: moduleId.version,
            };
            return this.createBundleDefinition(moduleId, metadata, localeId, debug, ssr, async () => '', normalizeFromFileURL(metadata.path, this.siteRootDir) ?? metadata.path);
        }
        if (!metadata) {
            this.logBundleError(moduleId, localeId, debug, ssr);
            return undefined;
        }
        // Default bundle source path
        const bundlePath = path.join(this.siteRootDir, metadata.path);
        // Get the associated bundle source code
        const codePromiser = this.getCodePromiser(bundlePath, {
            specifier,
            version,
            locale: localeId,
            ssr,
            debug,
        });
        return this.createBundleDefinition(moduleId, metadata, localeId, debug, ssr, codePromiser, bundlePath);
    }
    async createBundleDefinition(moduleId, metadata, localeId, debug, ssr, codePromiser, bundlePath) {
        const { specifier, name, namespace, version } = moduleId;
        const imports = metadata.imports.map((importSpecifier) => this.getModuleReference(importSpecifier, localeId, debug, false));
        const dynamicImports = metadata.dynamicImports?.map((importSpecifier) => this.getModuleReference(importSpecifier, localeId, debug, false));
        const id = getSpecifier(moduleId);
        const exploded = explodeSpecifier(id);
        // Seem unlikely name was not in the moduleId but just incase set it form the exploded id
        const resolvedName = name ?? exploded.name;
        const resolvedNamespace = namespace ?? exploded.namespace;
        const resolvedVersion = resolveStaticBundleVersion(metadata.version, version);
        const includedModules = metadata.includedModules?.map((includedId) => {
            const includedModule = this.getModuleReference(includedId, localeId, debug, ssr);
            return getSpecifier(includedModule);
        }) || [];
        return {
            getCode: codePromiser,
            id: getSpecifier({
                specifier: specifier,
                version: resolvedVersion,
                name: resolvedName,
                namespace: resolvedNamespace,
            }),
            name: resolvedName,
            namespace: resolvedNamespace,
            version: resolvedVersion,
            specifier: specifier,
            config: this.bundleConfig,
            integrity: metadata.integrity,
            bundleRecord: {
                // TODO we need to solve include modules for fingerprints support
                includedModules,
                imports,
                dynamicImports,
            },
            src: bundlePath,
        };
    }
    getBundleMetadata({ moduleId, localeId, debug, ssr, }) {
        const siteBundleId = getSiteBundleId(moduleId, localeId, ssr, this.i18n);
        return this.siteMetadata.getSiteBundlesDecisionTree().find(siteBundleId, debug);
    }
    /**
     * Takes a key from the site bundle metadata and creates an appropriate runtime BaseModuleReference to use in the LWR runtime.
     */
    getModuleReference(siteBundleIdStr, localeId, debug, ssr) {
        const siteBundleId = parseSiteId(siteBundleIdStr);
        const includedModule = explodeSpecifier(siteBundleId.specifier);
        if (!siteBundleId.variants[VERSION_SIGIL]) {
            const importBundleMetadata = this.siteMetadata
                .getSiteBundlesDecisionTree()
                .find(siteBundleIdStr, debug, ssr, localeId);
            includedModule.version = resolveStaticBundleVersion(importBundleMetadata?.version);
        }
        else {
            includedModule.version = siteBundleId.variants[VERSION_SIGIL];
        }
        return includedModule;
    }
    getCodePromiser(bundleSourcePath, { specifier, version, locale, ssr, debug, }) {
        const cache = this.codeCache;
        return async () => {
            let code = cache?.get(bundleSourcePath);
            if (!code) {
                try {
                    // Debug metadata was not found
                    if (bundleSourcePath === BUNDLE_SOURCE_NOT_FOUND) {
                        throw new Error(BUNDLE_SOURCE_NOT_FOUND);
                    }
                    // Increment the cache count store
                    cacheCountStore.incrementCacheKey('missedReads');
                    await getTracer().trace({
                        name: BundleSpan.ReadBundle,
                        attributes: {
                            specifier,
                            version: version ?? '',
                            locale,
                            ssr: ssr ? 'TRUE' : 'FALSE',
                            debug: debug ? 'TRUE' : 'FALSE',
                            bundleSourcePath,
                        },
                    }, async () => {
                        code = await fs.readFile(path.join(bundleSourcePath), 'utf-8');
                        if (cache) {
                            cache.set(bundleSourcePath, code);
                        }
                    });
                }
                catch (err) {
                    // Ran it an un-expected error reading the bundle source code
                    logger.warn({
                        label: 'static-bundle-provider',
                        message: `Unexpected code reference: ${specifier} ${bundleSourcePath}`,
                    }, err);
                    // Returning source code that throws and error is someone tries to evaluate it
                    code = `throw new Error('Unexpected code reference: ${specifier} ${bundleSourcePath}');`;
                    if (cache) {
                        cache.set(bundleSourcePath, code);
                    }
                }
            }
            return code;
        };
    }
    /**
     * Logs an error when a bundle fails to load and provides debugging metadata.
     *
     * This function logs details about the failed bundle load attempt, including the module ID,
     * locale, debug mode, and SSR status. It also attempts to retrieve additional metadata
     * about the site bundles and debug bundles associated with the module.
     *
     * @param {Partial<AbstractModuleId>} moduleId - The module identifier, which may include a namespace and name.
     * @param {string} localeId - The locale associated with the bundle.
     * @param {boolean} debug - Indicates whether debug mode is enabled.
     * @param {boolean} ssr - Indicates whether the bundle is for server-side rendering (SSR).
     */
    logBundleError(moduleId, localeId, debug, ssr) {
        const moduleSpecifier = moduleId.namespace
            ? `${moduleId.namespace}/${moduleId.name}`
            : moduleId.name;
        const siteBundleId = getSiteBundleId(moduleId, localeId, ssr, this.i18n);
        // Retrieve site bundles and debug bundles
        const siteBundles = this.siteMetadata.getSiteBundles()?.bundles || {};
        const siteDebugBundles = this.siteMetadata.getDebugSiteBundles()?.bundles || {};
        // Extract keys and filter bundles by module specifier
        const runtimeBundles = Object.keys(siteBundles).filter((key) => key.startsWith(moduleSpecifier));
        const debugBundles = Object.keys(siteDebugBundles).filter((key) => key.startsWith(moduleSpecifier));
        logger.error({
            message: JSON.stringify({
                message: 'Failed to find static bundle',
                moduleId,
                localeId,
                debug,
                ssr,
                moduleSpecifier,
                siteBundleId,
                debugBundles,
                runtimeBundles,
                totalBundlesCount: Object.keys(siteBundles).length,
                totalDebugBundlesCount: Object.keys(siteDebugBundles).length,
            }),
            label: 'static-bundle-provider',
        });
    }
}
//# sourceMappingURL=static-bundle-provider.js.map