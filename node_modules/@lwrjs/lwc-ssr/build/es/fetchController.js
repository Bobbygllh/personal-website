import { Pool as ClientPool } from 'undici';
import { logger, stringifyError } from '@lwrjs/diagnostics';
import { getTracer, ViewSpan } from '@lwrjs/instrumentation';
import { ROUTE_CORE_HEADER, getTraceHeaders, toHostname } from '@lwrjs/shared-utils';
// a single Lambda only services 1 org, so this cache will not grow too large
const CORE_CLIENTS = new Map();
/**
 * During SSR a context is created with a new fetchController. At this point any fetches work as expected in this context.
 *
 * Right before renderComponents we call activateNoOp. At this point any new fetch calls in this context result in a no-op
 * fetch waiting to be aborted.
 *
 * When SSR for this request is complete we call activateKillSwitch which aborts any pending fetch calls in this context.
 * Any new fetch calls (i.e. from other async function calls) would be immediately aborted.
 */
export class FetchController {
    killSwitchActivated;
    noOpActivated;
    abortController;
    headers;
    host;
    coreProxy;
    fetchEndowment;
    constructor(context) {
        this.killSwitchActivated = false;
        this.noOpActivated = false;
        this.setFetchRequestContext(context);
        this.fetchEndowment = this.createFetchEndowment();
    }
    controlledFetch = (request, init) => {
        if (this.killSwitchActivated) {
            return this.handleAbortError(request, 'Kill switch was already enabled');
        }
        if (!this.abortController) {
            this.abortController = new AbortController();
        }
        const signal = this.abortController?.signal;
        // Ensure the init object exists and then add the signal to it.
        const updatedInit = {
            ...init,
            headers: { ...init?.headers, ...this.headers },
            signal,
        };
        const fetchFunction = this.noOpActivated
            ? this.fetchNoOp(request, updatedInit)
            : this.fetchEndowment(request, updatedInit);
        const fetchPromise = fetchFunction.catch((error) => {
            // Check if the error is an AbortError
            const errorMsg = error.message || error;
            if (error && (errorMsg.startsWith('AbortError') || error?.stack.startsWith('AbortError'))) {
                return this.handleAbortError(request, error);
            }
            else {
                // Re-throw the error if it's not an AbortError
                throw error;
            }
        });
        return fetchPromise;
    };
    /**
     * After SSR is complete the kill switch will abort any pending fetch requests.
     */
    activateKillSwitch = () => {
        this.killSwitchActivated = true;
        this.abortController?.abort('AbortError: Kill switch enabled');
        this.abortController = undefined;
    };
    deactivateKillSwitch = () => {
        this.killSwitchActivated = false;
    };
    /**
     * During SSR renderComponent (which is synchronous) Do not even call any fetch requests
     * since they would not complete before SSR is done.
     */
    activateNoOp = () => {
        this.noOpActivated = true;
    };
    deactivateNoOp = () => {
        this.noOpActivated = false;
    };
    setFetchRequestContext = (context) => {
        const { abortController, host, headers, coreProxy } = context;
        this.host = host;
        this.headers = headers;
        this.coreProxy = coreProxy;
        this.abortController = abortController;
    };
    handleAbortError(request, error) {
        const message = `${String(request)} request was killed. Either the request timed out or it was dispatched during SSR. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
        logger.warn({ label: `Server-side Rendering`, message }, error);
        // Return a response to indicate kill switch
        return Promise.resolve(new Response(message, { status: 500 }));
    }
    /**
     * Create a fetch API that never calls a request.
     * This is not expected to be called without an AbortController setup.
     */
    fetchNoOp(request, init) {
        return new Promise((resolve) => {
            if (!init?.signal) {
                // This should not happen?  This is only called internally to the class and we setup an abort controller.
                resolve(this.handleAbortError(request, new Error('RequestInit was not setup as expected')));
            }
            else if (init.signal.aborted) {
                // The request was already aborted go ahead and return the abort error
                resolve(this.handleAbortError(request, new Error('Request was already aborted')));
            }
            else {
                // Wait until fetches are aborted to resolve with an abort error
                const abortHandler = (err) => {
                    init?.signal?.removeEventListener('abort', abortHandler);
                    // Resolve the fetch
                    resolve(this.handleAbortError(request, new Error('Not allowed: Request was dispatched during SSR', { cause: err })));
                };
                init.signal.addEventListener('abort', abortHandler);
            }
        });
    }
    createFetchEndowment() {
        return (request, init = {}) => {
            const { host: forwardedOrigin = '', coreProxy } = this;
            // The Direct-to-Core proxy origin takes precedence over the Forwarded host
            const origin = coreProxy?.origin && coreProxy.origin.startsWith('http') ? coreProxy.origin : forwardedOrigin;
            const { finalRequest, finalUrl } = this.getFinalRequest(request, origin);
            if (coreProxy || (forwardedOrigin && finalUrl.startsWith(forwardedOrigin))) {
                // hint for the CDN that the request is targeted to Core
                init.headers[ROUTE_CORE_HEADER] = 'true';
            }
            const proxyStr = coreProxy ? JSON.stringify(coreProxy) : 'none';
            const hasCookies = this.headers && this.headers.Cookie ? 'yes' : 'no';
            logger.info({
                label: `pre ${ViewSpan.Fetch}`,
                message: `finalUrl: ${finalUrl}, coreProxy: ${proxyStr}, hasCookies: ${hasCookies}`,
            });
            return getTracer().trace(
            // fetchType is one of ['cdn' (default), 'direct', 'cdnFallback']
            // Default URL to  final URL if successful addInfoToSpan will replace with response.url
            {
                name: ViewSpan.Fetch,
                attributes: {
                    url: finalUrl,
                    fetchType: 'cdn',
                    forwardedOrigin,
                    coreProxy: proxyStr,
                    hasCookies,
                },
            }, (span) => {
                // this trace will NOT fail if fetch fails; it is meant to log the URLs fetched from the server
                // the fetch caller (ie: getServerData) should handle the error if response.ok is false
                // if the caller throws the fetch error, then it will be surfaced in the PARENT traces:
                // lwr.view.ssr.fetch (this) > lwr.view.ssr > lwr.view.ssr.island > lwr.view.render > lwr.handle.view
                const addInfoToSpan = (res) => {
                    // add attributes to the trace which are only available post-fetch
                    res.url && span.setAttributes({ url: res.url }); // res.url is '' with undici
                    span.setAttributes({ statusCode: res.status });
                    return res;
                };
                const addErrorToSpan = (err) => {
                    // add fetch errors to the trace
                    span.setAttributes({ error: stringifyError(err) });
                };
                // add tracing headers based on span values
                init.headers = { ...init.headers, ...getTraceHeaders({}, span) };
                if (coreProxy) {
                    return this.fetchWithAgent(finalUrl, init, forwardedOrigin, coreProxy, span)
                        .then((res) => addInfoToSpan(res))
                        .catch((err) => {
                        const { finalRequest: cdnRequest, finalUrl: cdnUrl } = this.getFinalRequest(request, forwardedOrigin);
                        logger.warn(`Fetching data directly from Core failed, retrying through CDN: ${cdnUrl} Error is: ${err.message || err}`);
                        span.setAttributes({ fetchType: 'cdnFallback' });
                        return fetch(cdnRequest, init)
                            .then((res) => addInfoToSpan(res))
                            .catch((e) => {
                            addErrorToSpan(e);
                            throw e;
                        });
                    });
                }
                return fetch(finalRequest, init)
                    .then((res) => addInfoToSpan(res))
                    .catch((e) => {
                    addErrorToSpan(e);
                    throw e;
                });
            });
        };
    }
    getFinalRequest(request, origin) {
        let finalRequest;
        let finalUrl;
        if (request instanceof Request) {
            const curUrl = request.url;
            // proxy relative URLs through the origin
            if (curUrl.startsWith('/')) {
                finalUrl = origin + curUrl;
                finalRequest = new Request(finalUrl, request);
            }
            else {
                finalUrl = curUrl;
                finalRequest = request;
            }
        }
        else {
            const curUrl = typeof request === 'string' ? request : request.toString(); // handle string-able types, eg: URL
            finalRequest = finalUrl = curUrl.startsWith('/') ? origin + curUrl : curUrl; // proxy relative URLs through the origin
        }
        return { finalRequest, finalUrl };
    }
    async fetchWithAgent(rawUrl, init, forwardedOrigin, coreProxy, span) {
        let { origin, servername } = coreProxy;
        const forwardedHostname = toHostname(forwardedOrigin);
        const hostHeader = coreProxy.host ?? forwardedHostname;
        const ENHANCED_DOMAIN_TLD = '.site.com';
        const MY_DOMAIN_TLD = '.salesforce.com';
        if (forwardedHostname.endsWith(ENHANCED_DOMAIN_TLD)) {
            const myHostname = forwardedHostname.slice(0, -ENHANCED_DOMAIN_TLD.length) + MY_DOMAIN_TLD;
            // use the Salesforce TLD by replacing the Site TLD
            // caller must be an Enhanced Domain on Cloudflare
            origin = 'https://' + myHostname;
            // do not use SNI with the Enhanced Domain route
            // never include a protocol in the servername
            servername = myHostname;
        }
        else if (origin.startsWith('.')) {
            // use the CDN origin if the leading '.' is missing in the coreProxy origin
            origin = 'https://' + forwardedHostname + origin;
        }
        const urlParts = new URL(rawUrl);
        const path = urlParts.pathname + urlParts.search;
        const url = origin + path;
        // The host header and servername attrs are only used for Direct-to-Core requests
        // They are not used again if this request fails and falls back to CDN
        span.setAttributes({
            fetchType: 'direct',
            url,
            coreUrl: url,
            coreHostHeader: hostHeader,
            coreServername: servername,
        });
        let client = CORE_CLIENTS.get(origin);
        if (!client) {
            client = new ClientPool(origin, {
                connections: parseInt(process.env.CLIENT_CONNECTION_LIMIT ?? '100', 10),
                keepAliveTimeout: 30000,
            });
            CORE_CLIENTS.set(origin, client);
        }
        return client
            .request({
            ...init,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - HttpMethod not available for typecasting :|
            method: init.method || 'GET',
            path,
            headers: { ...init?.headers, Host: hostHeader },
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - not properly typed >:|
            servername,
        })
            .then(async (res) => {
            // Set the core* attrs early, so the info is not lost if we fallback to CDN
            // With no CDN fallback url=coreUrl and statusCode=coreStatusCode
            span.setAttributes({ coreStatusCode: res.statusCode });
            // convert the response to a fetch Response object
            // downstream consumers expect a Response since it's the standard fetch return object
            // this allows callers to check the response with "instanceof Response"
            const bodyBuffer = await res.body.arrayBuffer();
            const body = res.statusCode === 204 || res.statusCode === 205 ? null : bodyBuffer;
            const headers = new Headers();
            for (const [key, value] of Object.entries(res.headers)) {
                if (!value)
                    continue;
                const values = Array.isArray(value) ? value : [value];
                values.forEach((v) => headers.append(key, v));
            }
            return new Response(body, { status: res.statusCode, headers });
        });
    }
}
//# sourceMappingURL=fetchController.js.map