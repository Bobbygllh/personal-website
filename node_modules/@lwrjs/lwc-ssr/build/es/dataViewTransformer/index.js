import { descriptions, logger, LwrStatusError, stringifyError } from '@lwrjs/diagnostics';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { addHeadMarkup } from '@lwrjs/shared-utils';
import { mergeWarnings } from '../utils.js';
import { getRenderer } from '../renderer.js';
const NAME = 'preload-data-transformer';
/**
 * This view transformer preloads data on the server for CSRed routes.
 * If the route has:
 *  - a "rootComponent" and
 *  - the "ssr" bootstrap flag is OFF
 * then it will:
 *  - run getServerData() from the rootComponent and
 *  - serialize the output into globalThis.LWR.serverData
 * To consume the data on the client, access globalThis.LWR.serverData from a bootstrap service.
 */
export default function preloadDataViewTransformer(_options, { config, moduleBundler, resourceRegistry }) {
    const routes = [...config.routes, ...config.errorRoutes];
    return {
        name: NAME,
        async link(stringBuilder, viewContext, metadata) {
            const allBundles = new Set([...(metadata.serverBundles ?? [])]); // make a copy
            const { rootComponent } = viewContext.view;
            if (!rootComponent ||
                !viewContext.view.bootstrap?.preloadData ||
                viewContext.view.bootstrap?.ssr) {
                return {}; // must be a CSRed rootComponent with preloadData ON
            }
            logger.debug({ label: NAME, message: `Preload data for root component "${rootComponent}"` });
            const { results = {}, warnings, bundles, } = await getTracer().trace({
                name: ViewSpan.PreloadData,
                attributes: { rootComponent },
            }, async () => {
                const route = routes.find((r) => r.id === viewContext.view.id);
                if (!route) {
                    throw new Error(`Unable to resolve configuration for view: ${viewContext.view.id}`);
                }
                try {
                    return await getRenderer(config, moduleBundler, resourceRegistry).render({ [rootComponent]: { specifier: rootComponent, props: {} } }, route, viewContext.runtimeEnvironment, viewContext.runtimeParams);
                }
                catch (e) {
                    // Pass redirects along
                    if (e instanceof LwrStatusError)
                        throw e;
                    // If we find errors just log as warnings since these are SSR errors for a CSR page
                    const message = descriptions.APPLICATION.PRELOAD_DATA_ERROR(rootComponent, stringifyError(e));
                    logger.warn({ label: 'preloadDataViewTransformer', message });
                    return { warnings: [message] }; // return 0 results
                }
            });
            mergeWarnings(metadata, warnings);
            const result = results[rootComponent];
            if (!result) {
                // Returns no data since there was an error loading modules
                return {};
            }
            // Log and process the data response
            const { props, markup, cache: { ttl } = { ttl: undefined } } = result || {};
            logger.verbose({ label: NAME, message: 'response', additionalInfo: props });
            markup && addHeadMarkup([result.markup], stringBuilder); // add links to the <head> tag
            metadata.serverData = metadata.serverData || {}; // create serverData if necessary
            Object.assign(metadata.serverData, props); // add the preloaded data to serverData for serialization
            metadata.serverBundles = bundles ? new Set([...allBundles, ...bundles]) : allBundles; // add server bundles for preloadData
            return { cache: { ttl } };
        },
    };
}
//# sourceMappingURL=index.js.map