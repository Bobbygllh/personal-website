var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/fetchController.ts
__markAsModule(exports);
__export(exports, {
  FetchController: () => FetchController
});
var import_undici = __toModule(require("undici"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var CORE_CLIENTS = new Map();
var FetchController = class {
  constructor(context) {
    this.controlledFetch = (request, init) => {
      if (this.killSwitchActivated) {
        return this.handleAbortError(request, "Kill switch was already enabled");
      }
      if (!this.abortController) {
        this.abortController = new AbortController();
      }
      const signal = this.abortController?.signal;
      const updatedInit = {
        ...init,
        headers: {...init?.headers, ...this.headers},
        signal
      };
      const fetchFunction = this.noOpActivated ? this.fetchNoOp(request, updatedInit) : this.fetchEndowment(request, updatedInit);
      const fetchPromise = fetchFunction.catch((error) => {
        const errorMsg = error.message || error;
        if (error && (errorMsg.startsWith("AbortError") || error?.stack.startsWith("AbortError"))) {
          return this.handleAbortError(request, error);
        } else {
          throw error;
        }
      });
      return fetchPromise;
    };
    this.activateKillSwitch = () => {
      this.killSwitchActivated = true;
      this.abortController?.abort("AbortError: Kill switch enabled");
      this.abortController = void 0;
    };
    this.deactivateKillSwitch = () => {
      this.killSwitchActivated = false;
    };
    this.activateNoOp = () => {
      this.noOpActivated = true;
    };
    this.deactivateNoOp = () => {
      this.noOpActivated = false;
    };
    this.setFetchRequestContext = (context) => {
      const {abortController, host, headers, coreProxy} = context;
      this.host = host;
      this.headers = headers;
      this.coreProxy = coreProxy;
      this.abortController = abortController;
    };
    this.killSwitchActivated = false;
    this.noOpActivated = false;
    this.setFetchRequestContext(context);
    this.fetchEndowment = this.createFetchEndowment();
  }
  handleAbortError(request, error) {
    const message = `${String(request)} request was killed. Either the request timed out or it was dispatched during SSR. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
    import_diagnostics.logger.warn({label: `Server-side Rendering`, message}, error);
    return Promise.resolve(new Response(message, {status: 500}));
  }
  fetchNoOp(request, init) {
    return new Promise((resolve) => {
      if (!init?.signal) {
        resolve(this.handleAbortError(request, new Error("RequestInit was not setup as expected")));
      } else if (init.signal.aborted) {
        resolve(this.handleAbortError(request, new Error("Request was already aborted")));
      } else {
        const abortHandler = (err) => {
          init?.signal?.removeEventListener("abort", abortHandler);
          resolve(this.handleAbortError(request, new Error("Not allowed: Request was dispatched during SSR", {cause: err})));
        };
        init.signal.addEventListener("abort", abortHandler);
      }
    });
  }
  createFetchEndowment() {
    return (request, init = {}) => {
      const {host: forwardedOrigin = "", coreProxy} = this;
      const origin = coreProxy?.origin && coreProxy.origin.startsWith("http") ? coreProxy.origin : forwardedOrigin;
      const {finalRequest, finalUrl} = this.getFinalRequest(request, origin);
      if (coreProxy || forwardedOrigin && finalUrl.startsWith(forwardedOrigin)) {
        init.headers[import_shared_utils.ROUTE_CORE_HEADER] = "true";
      }
      const proxyStr = coreProxy ? JSON.stringify(coreProxy) : "none";
      const hasCookies = this.headers && this.headers.Cookie ? "yes" : "no";
      import_diagnostics.logger.info({
        label: `pre ${import_instrumentation.ViewSpan.Fetch}`,
        message: `finalUrl: ${finalUrl}, coreProxy: ${proxyStr}, hasCookies: ${hasCookies}`
      });
      return (0, import_instrumentation.getTracer)().trace({
        name: import_instrumentation.ViewSpan.Fetch,
        attributes: {
          url: finalUrl,
          fetchType: "cdn",
          forwardedOrigin,
          coreProxy: proxyStr,
          hasCookies
        }
      }, (span) => {
        const addInfoToSpan = (res) => {
          res.url && span.setAttributes({url: res.url});
          span.setAttributes({statusCode: res.status});
          return res;
        };
        const addErrorToSpan = (err) => {
          span.setAttributes({error: (0, import_diagnostics.stringifyError)(err)});
        };
        init.headers = {...init.headers, ...(0, import_shared_utils.getTraceHeaders)({}, span)};
        if (coreProxy) {
          return this.fetchWithAgent(finalUrl, init, forwardedOrigin, coreProxy, span).then((res) => addInfoToSpan(res)).catch((err) => {
            const {finalRequest: cdnRequest, finalUrl: cdnUrl} = this.getFinalRequest(request, forwardedOrigin);
            import_diagnostics.logger.warn(`Fetching data directly from Core failed, retrying through CDN: ${cdnUrl} Error is: ${err.message || err}`);
            span.setAttributes({fetchType: "cdnFallback"});
            return fetch(cdnRequest, init).then((res) => addInfoToSpan(res)).catch((e) => {
              addErrorToSpan(e);
              throw e;
            });
          });
        }
        return fetch(finalRequest, init).then((res) => addInfoToSpan(res)).catch((e) => {
          addErrorToSpan(e);
          throw e;
        });
      });
    };
  }
  getFinalRequest(request, origin) {
    let finalRequest;
    let finalUrl;
    if (request instanceof Request) {
      const curUrl = request.url;
      if (curUrl.startsWith("/")) {
        finalUrl = origin + curUrl;
        finalRequest = new Request(finalUrl, request);
      } else {
        finalUrl = curUrl;
        finalRequest = request;
      }
    } else {
      const curUrl = typeof request === "string" ? request : request.toString();
      finalRequest = finalUrl = curUrl.startsWith("/") ? origin + curUrl : curUrl;
    }
    return {finalRequest, finalUrl};
  }
  async fetchWithAgent(rawUrl, init, forwardedOrigin, coreProxy, span) {
    let {origin, servername} = coreProxy;
    const forwardedHostname = (0, import_shared_utils.toHostname)(forwardedOrigin);
    const hostHeader = coreProxy.host ?? forwardedHostname;
    const ENHANCED_DOMAIN_TLD = ".site.com";
    const MY_DOMAIN_TLD = ".salesforce.com";
    if (forwardedHostname.endsWith(ENHANCED_DOMAIN_TLD)) {
      const myHostname = forwardedHostname.slice(0, -ENHANCED_DOMAIN_TLD.length) + MY_DOMAIN_TLD;
      origin = "https://" + myHostname;
      servername = myHostname;
    } else if (origin.startsWith(".")) {
      origin = "https://" + forwardedHostname + origin;
    }
    const urlParts = new URL(rawUrl);
    const path = urlParts.pathname + urlParts.search;
    const url = origin + path;
    span.setAttributes({
      fetchType: "direct",
      url,
      coreUrl: url,
      coreHostHeader: hostHeader,
      coreServername: servername
    });
    let client = CORE_CLIENTS.get(origin);
    if (!client) {
      client = new import_undici.Pool(origin, {
        connections: parseInt(process.env.CLIENT_CONNECTION_LIMIT ?? "100", 10),
        keepAliveTimeout: 3e4
      });
      CORE_CLIENTS.set(origin, client);
    }
    return client.request({
      ...init,
      method: init.method || "GET",
      path,
      headers: {...init?.headers, Host: hostHeader},
      servername
    }).then(async (res) => {
      span.setAttributes({coreStatusCode: res.statusCode});
      const bodyBuffer = await res.body.arrayBuffer();
      const body = res.statusCode === 204 || res.statusCode === 205 ? null : bodyBuffer;
      const headers = new Headers();
      for (const [key, value] of Object.entries(res.headers)) {
        if (!value)
          continue;
        const values = Array.isArray(value) ? value : [value];
        values.forEach((v) => headers.append(key, v));
      }
      return new Response(body, {status: res.statusCode, headers});
    });
  }
};
