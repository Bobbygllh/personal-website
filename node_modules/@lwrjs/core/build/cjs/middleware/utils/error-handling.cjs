var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/middleware/utils/error-handling.ts
__markAsModule(exports);
__export(exports, {
  handleErrors: () => handleErrors
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_diagnostics2 = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
function addRedirectQueryParam(redirectUrl, depth) {
  const fakeOrigin = "http://parse.com";
  const url = (0, import_shared_utils.isURL)(redirectUrl) ? new URL(redirectUrl) : new URL(`${fakeOrigin}${redirectUrl}`);
  url.searchParams.set(import_shared_utils.REQUEST_DEPTH_HEADER, String(depth + 1));
  return url.toString().replace(fakeOrigin, "");
}
function createReturnStatus(error, req, debug, isBaseDoc) {
  let status = 500, body = error.message || "";
  const headers = {};
  if (error instanceof import_diagnostics.LwrStatusError) {
    status = error.status;
    const rawHeaders = error.headers || {};
    Object.entries(rawHeaders).forEach(([key, value]) => headers[key.toLowerCase()] = value);
    if (status === 301 || status === 302) {
      const location = headers.location;
      if (location && (0, import_shared_utils.isURL)(location) || location?.startsWith("/")) {
        headers.location = addRedirectQueryParam(location, (0, import_shared_utils.parseRequestDepth)(req.headers, req.query));
      } else {
        import_diagnostics2.logger.warn(`[error-middleware] Invalid location header for HTTP status ${status}: "${location}"`);
      }
    }
  }
  if (error instanceof import_diagnostics.LwrInvalidError) {
    status = 400;
  } else if (error instanceof import_diagnostics.LwrUnresolvableError) {
    status = isBaseDoc ? 500 : 404;
  } else {
    body = error instanceof import_diagnostics.LwrError ? body : `${import_diagnostics.descriptions.SERVER.SERVER_ERROR(req.originalUrl)}: ${body}`;
  }
  if (debug) {
    body = `<div style="font-family:sans-serif;margin:50px;"><h1>${status}: Document generation failed</h1><p>${body.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p></div>`;
    status = 200;
  }
  return {status, body, headers: Object.keys(headers).length > 0 ? headers : void 0};
}
function handleErrors(middleware, isBaseDoc = false) {
  return async (req, res, next) => {
    try {
      await middleware(req, res, next);
    } catch (err) {
      if (err instanceof import_diagnostics.DiagnosticsError) {
        import_diagnostics2.logger.error("LWR Diagnostic Error: " + err.message);
        import_diagnostics2.logger.error(err.diagnostics);
        import_diagnostics2.logger.error(err.stack);
      } else {
        import_diagnostics2.logger.error(err);
      }
      const {status, body, headers} = createReturnStatus(err, req, req.query.debug !== void 0 && isBaseDoc, isBaseDoc);
      headers && res.set(headers);
      res.status(status).send(body);
    }
  };
}
