import { descriptions, DiagnosticsError, LwrError, LwrInvalidError, LwrStatusError, LwrUnresolvableError, } from '@lwrjs/diagnostics';
import { logger } from '@lwrjs/diagnostics';
import { isURL, parseRequestDepth, REQUEST_DEPTH_HEADER } from '@lwrjs/shared-utils';
function addRedirectQueryParam(redirectUrl, depth) {
    // add a request depth query param to the URL
    // the depth header cannot be used since headers cannot be added to a redirect
    const fakeOrigin = 'http://parse.com';
    const url = isURL(redirectUrl) ? new URL(redirectUrl) : new URL(`${fakeOrigin}${redirectUrl}`);
    url.searchParams.set(REQUEST_DEPTH_HEADER, String(depth + 1));
    return url.toString().replace(fakeOrigin, '');
}
function createReturnStatus(error, req, debug, isBaseDoc) {
    let status = 500, body = error.message || '';
    const headers = {};
    if (error instanceof LwrStatusError) {
        // handle special HTTP statuses, eg: 301, 302, 429, 503
        status = error.status;
        const rawHeaders = error.headers || {};
        Object.entries(rawHeaders).forEach(([key, value]) => (headers[key.toLowerCase()] = value));
        if (status === 301 || status === 302) {
            // handle redirect
            const location = headers.location;
            if ((location && isURL(location)) || location?.startsWith('/')) {
                headers.location = addRedirectQueryParam(location, parseRequestDepth(req.headers, req.query));
            }
            else {
                logger.warn(`[error-middleware] Invalid location header for HTTP status ${status}: "${location}"`);
            }
        }
    }
    if (error instanceof LwrInvalidError) {
        status = 400;
    }
    else if (error instanceof LwrUnresolvableError) {
        // if something is missing during base doc generation, the status is 500
        // eg: a bundle cannot be found during SSR -> the page fails with a 500
        status = isBaseDoc ? 500 : 404;
    }
    else {
        // catchall: likely a LwrServerError
        body =
            error instanceof LwrError
                ? body
                : `${descriptions.SERVER.SERVER_ERROR(req.originalUrl)}: ${body}`;
    }
    if (debug) {
        // return a debug base doc and a 200 response code if debug mode is on
        body = `<div style="font-family:sans-serif;margin:50px;"><h1>${status}: Document generation failed</h1><p>${body.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p></div>`;
        status = 200;
    }
    return { status, body, headers: Object.keys(headers).length > 0 ? headers : undefined };
}
export function handleErrors(middleware, isBaseDoc = false) {
    return async (req, res, next) => {
        try {
            await middleware(req, res, next);
        }
        catch (err) {
            if (err instanceof DiagnosticsError) {
                logger.error('LWR Diagnostic Error: ' + err.message);
                logger.error(err.diagnostics);
                logger.error(err.stack);
            }
            else {
                logger.error(err);
            }
            const { status, body, headers } = createReturnStatus(err, req, 
            // only return HTML error screen for base doc requests in debug mode
            req.query.debug !== undefined && isBaseDoc, isBaseDoc);
            headers && res.set(headers);
            res.status(status).send(body);
        }
    };
}
//# sourceMappingURL=error-handling.js.map