import { logger } from '@lwrjs/diagnostics';
import { CORRELATION_ID, MRT_REQUEST_CLASS, REQUEST_DEPTH_HEADER, TRUE_CLIENT_IP, isLambdaEnv, parseRequestDepth, } from '@lwrjs/shared-utils';
export function requestProcessorMiddleware(app, context) {
    const { basePath } = context.runtimeEnvironment;
    app.use(async (req, res, next) => {
        let requestClass;
        let requestDepth;
        if (req.headers) {
            // If debug print log all the headers
            if (logger.isDebugEnabled()) {
                // Loop through and print each header
                for (const headerName in req.headers) {
                    logger.debug({
                        label: `request-processor-middleware`,
                        message: `Header ${headerName}: ${req.headers[headerName]}`,
                    });
                }
            }
            requestClass = req.headers[MRT_REQUEST_CLASS];
            requestDepth = parseRequestDepth(req.headers, req.query);
            const trueClientIP = req.headers[TRUE_CLIENT_IP];
            const correlationID = req.headers[CORRELATION_ID];
            const forwarded = req.headers['forwarded'];
            const host = req.headers['host'];
            const forwardedProto = req.headers['x-forwarded-proto'];
            const protocol = req.protocol;
            const cookieLength = req.headers['cookie']?.length || 0;
            let cookieMsg = `Cookie length: ${cookieLength}`;
            if (cookieLength) {
                cookieMsg += `, Cookie has '__Secure-has-sid': ${!!req.cookie('__Secure-has-sid')}, Cookie has 'sid': ${!!req.cookie('sid')}`;
            }
            // Only Add this log when on MRT.  Useful to catch issues where CDN did not send us the right info.
            if (isLambdaEnv()) {
                logger.info({
                    label: `request-processor-middleware`,
                    message: `Original Url: ${req.originalUrl}, Forwarded: ${forwarded}, X-Forwarded-Proto: ${forwardedProto}, Host: ${host}, Protocol: ${protocol}, ${cookieMsg}, ${MRT_REQUEST_CLASS}: ${requestClass}, ${TRUE_CLIENT_IP}: ${trueClientIP}, ${CORRELATION_ID}: ${correlationID}, ${REQUEST_DEPTH_HEADER}: ${requestDepth}`,
                });
            }
        }
        if (requestDepth && requestDepth > 1) {
            logger.error({
                label: 'request-processor-middleware',
                message: `Lambda SSR request cycle detected: ${req.originalUrl}`,
            });
            // Return 400 Too Many Requests status
            return res.status(400).send('Request depth limit reached');
        }
        if (req.headers && requestClass && typeof requestClass === 'string') {
            const parsedRequestClass = parseRequestClass(requestClass);
            logger.debug({
                label: `request-processor-middleware`,
                message: `parsedRequestClass?.basePath: ${parsedRequestClass?.basePath}`,
            });
            const pathValue = parsedRequestClass?.basePath || basePath || '';
            // If base path is '' or starts with / leave it alone
            req.basePath = pathValue === '' || pathValue.indexOf('/') === 0 ? pathValue : `/${pathValue}`;
            const expressRequest = req.req;
            // This section is code added for the 103 hints support.  If CDN passes us a basePath in the header
            // If the basePath is at the start of the URL we need to remove it so we can match the expected route.
            if (expressRequest?.url && parsedRequestClass?.basePath) {
                // Separate the path and the query param using dummy local host here since we do not use it
                const { pathname, search } = new URL(expressRequest.url, 'http://localhost');
                if (pathname.startsWith(parsedRequestClass.basePath)) {
                    // Remove the basePath from the pathname
                    const newPath = pathname.slice(parsedRequestClass.basePath.length) || '/';
                    // Reconstruct the URL with the modified path and original query string
                    expressRequest.url = newPath + search;
                    expressRequest.originalUrl = newPath + search;
                }
                else {
                    logger.warn({
                        label: `request-processor-middleware`,
                        message: `The URL requested for doesn't start with the Base path`,
                    });
                }
            }
        }
        else {
            logger.debug({
                label: `request-processor-middleware`,
                message: `${MRT_REQUEST_CLASS} ignored ${req.headers ? req.headers[MRT_REQUEST_CLASS] : 'no-headers'}`,
            });
            req.basePath = basePath;
        }
        // await is required when calling next to support koa
        await next();
    });
}
/**
 * Parse the basePath passed via the X-Mobify-Request-Class header.
 * Example: basePath=/token
 *
 * basePath: The dynamic base path
 *  '' or undefined -> LWR basePath ''
 *  token or /token -> LWR basePath '/token'
 *
 */
function parseRequestClass(requestClass) {
    // If there is no requestClass do not bother parsing
    if (!requestClass) {
        return {};
    }
    // Split the header into individual key-value pairs
    const keyValuePairs = requestClass.split(';');
    // Create an object to store the parsed values
    const parsed = {};
    // Iterate through the key-value pairs and populate the parsed object
    for (const pair of keyValuePairs) {
        const [key, value] = pair.split('=');
        parsed[key] = value;
    }
    return parsed;
}
//# sourceMappingURL=request-processor-middleware.js.map