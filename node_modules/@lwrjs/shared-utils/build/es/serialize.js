import ms from 'ms';
import { logger } from '@lwrjs/diagnostics';
// Given a Module Identifier, return a JSON entry
async function createJsonModule(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams) {
    const { ownHash, moduleEntry: { version }, } = await moduleRegistry.getModule(moduleId, runtimeParams);
    return {
        specifier: moduleId.specifier,
        version,
        ownHash,
        links: {
            self: await moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, ownHash),
        },
    };
}
/**
 * Take a Module Definition and return its JSON serialization
 *
 * @param code - the compiled code string for the given module
 * @param param1 - the Module Definition to serialize
 * @param moduleRegistry
 * @returns - Promise to the JSON serialization of the module
 */
export async function serializeModuleToJson(code = '', { specifier, version, ownHash, runtimeEnvironment, linkedConfig: { minified }, moduleRecord: { imports = [] }, }, moduleRegistry, runtimeParams) {
    const { format } = runtimeEnvironment;
    // Build the dependencies array
    const dependencies = imports.map((dep) => createJsonModule(dep, moduleRegistry, runtimeEnvironment, runtimeParams));
    return {
        specifier,
        version,
        ownHash,
        dependencies: await Promise.all(dependencies),
        format,
        minified,
        code,
    };
}
/**
 * Replace a part of a source string at the indices with a different value
 *
 * @param src - source string
 * @param param1 - offset indices
 * @param replaceValue - replacement
 */
export function replaceStringFromLocation(src, { startOffset, endOffset }, replaceValue) {
    return src.substr(0, startOffset) + replaceValue + src.substr(endOffset, src.length);
}
/**
 * Given two TTLs, return the shortest one
 * @param newTtl - time-to-live: time string or number of seconds
 * @param oldTtl - the current shortest TTL (if it exists)
 * @returns - the shorter of the two TTLs IN SECONDS, undefined if both TTLs are missing
 */
export function shortestTtl(newTtl, oldTtl, maxTtl) {
    if (newTtl === undefined && oldTtl === undefined)
        return undefined;
    const newSeconds = typeof newTtl === 'string' ? ms(newTtl) / 1000 : newTtl;
    const oldSeconds = typeof oldTtl === 'string' ? ms(oldTtl) / 1000 : oldTtl;
    const maxSeconds = typeof maxTtl === 'string' ? ms(maxTtl) / 1000 : maxTtl;
    let shortest = undefined;
    if (newSeconds !== undefined && (shortest === undefined || newSeconds < shortest)) {
        shortest = newSeconds;
    }
    if (oldSeconds !== undefined && (shortest === undefined || oldSeconds < shortest)) {
        shortest = oldSeconds;
    }
    if (maxSeconds !== undefined && (shortest === undefined || maxSeconds < shortest)) {
        shortest = maxSeconds;
    }
    return shortest;
}
/** HEAD MARKUP UTILS */
function createMetaTags(meta) {
    return meta.reduce((metaStr, { name, content, httpEquiv }) => {
        if (!name && !content && !httpEquiv)
            return metaStr; // do not create empty <meta> tags
        const nameStr = name ? ` name="${name}"` : '', httpEquivStr = httpEquiv ? ` http-equiv="${httpEquiv}"` : '', contentStr = content ? ` content="${content}"` : '';
        return metaStr + `<meta${nameStr}${httpEquivStr}${contentStr}>\n`;
    }, '');
}
function createScriptTags(scripts) {
    return scripts.reduce((scriptStr, { body }) => scriptStr + `<script type="application/ld+json">${body}</script>\n`, '');
}
function createLinkTags(links) {
    return links.reduce((linkStr, { href, rel, as, fetchpriority }) => {
        const relStr = rel ? ` rel="${rel}"` : '', asStr = as ? ` as="${as}"` : '', fetchStr = fetchpriority ? ` fetchpriority="${fetchpriority}"` : '';
        return linkStr + `<link href="${href}"${relStr}${asStr}${fetchStr}>\n`;
    }, '');
}
function createStyleTags(styles) {
    return styles.reduce((styleStr, { body, id }) => {
        const idStr = id ? ` id="${id}"` : '';
        return styleStr + `<style type="text/css"${idStr}>${body}</style>\n`;
    }, '');
}
/**
 * Serialize head markup metadata into an HTML string
 * @param markup An array of markup metadata objects
 * @returns A string of HTML generated from markup metadata
 */
export function createHeadMarkup(markup) {
    // Loop through the <title>, <script>, <meta>, and <link> tag information
    // Create an HTML string for each tag
    let hasTitle = false;
    return markup.reduce((str, { title, scripts = [], meta = [], links = [], styles = [] } = {}) => {
        if (title && !hasTitle) {
            // first <title> wins
            hasTitle = true;
            str += `<title>${title}</title>\n`;
        }
        return (str +
            createMetaTags(meta) +
            createScriptTags(scripts) +
            createLinkTags(links) +
            createStyleTags(styles));
    }, '');
}
/**
 * Serialize HeadMarkup config into HTML, then add it to the <head> of a base doc
 * @param markup An array of markup metadata objects
 * @param stringBuilder The string builder for a base document
 */
export function addHeadMarkup(markup, stringBuilder) {
    // Create HTML tags for each item in the SsrDataResponse.markup bag
    const headMarkup = createHeadMarkup(markup);
    if (headMarkup) {
        // Add all the links to the <head> section of the base document
        addToHead(headMarkup, stringBuilder);
    }
}
/**
 * Add an HTML string to the <head> of a base doc
 * @param markup An HTML string
 * @param stringBuilder The string builder for a base document
 */
export function addToHead(markup, stringBuilder) {
    // Create HTML tags for each item in the SsrDataResponse.markup bag
    if (markup) {
        // Add all the links to the <head> section of the base document
        const headIndex = stringBuilder.original.indexOf('</head>');
        if (headIndex >= 0) {
            stringBuilder.prependLeft(headIndex, markup);
        }
        else {
            logger.error('Adding head markup failed. Could not find the </head> tag.');
        }
    }
}
//# sourceMappingURL=serialize.js.map