if (getFeatureFlags().REEVALUATE_MODULES && !getFeatureFlags().LEGACY_LOADER) {
    throw new Error('REEVALUATE_MODULES is only supported with LEGACY_LOADER');
}
export function getFeatureFlags() {
    return {
        // Should we load load the assets from the lambda on MRT
        ASSETS_ON_LAMBDA: parseBooleanFlag('ASSETS_ON_LAMBDA'),
        // Number of BundleDefinition and BundleCode instances held in memory
        BUNDLE_CACHE_SIZE: parseStringFlag('BUNDLE_CACHE_SIZE'),
        ENABLE_NONCE: parseBooleanFlag('ENABLE_NONCE'),
        // AMD Module Bundles include un-versioned aliases
        EXPERIMENTAL_UNVERSIONED_ALIASES: parseBooleanFlag('EXPERIMENTAL_UNVERSIONED_ALIASES'),
        // DEFAULT LEGACY_LOADER = false;
        LEGACY_LOADER: parseBooleanFlag('LEGACY_LOADER'),
        // Enable metrics log level 'off', 'default' or 'verbose'
        LWR_TRACING: parseTracingFlag(),
        // Turn off distributed tracing (B3 headers, traceparent meta tag, MRT span exporting)
        DISABLE_B3_TRACING: parseBooleanFlag('DISABLE_B3_TRACING'),
        // Max size of ViewDefinition time to live
        MAX_VIEW_CACHE_TTL: parseStringFlag('MAX_VIEW_CACHE_TTL'),
        // Forces SSR to re-evaluate modules for every page render. By default, modules are evaluated only once.
        REEVALUATE_MODULES: parseBooleanFlag('REEVALUATE_MODULES'),
        // Use the LWC SSR compiler and v2 SSR API
        SSR_COMPILER_ENABLED: parseBooleanFlag('SSR_COMPILER_ENABLED'),
        // Create a new SSR Loader on every request
        SSR_LOADER_PER_REQUEST: parseBooleanFlag('SSR_LOADER_PER_REQUEST'),
        // Max number of ViewDefinitions help in memory
        VIEW_CACHE_SIZE: parseStringFlag('VIEW_CACHE_SIZE'),
        // Allows setting/overriding headers for non-immutable assets.
        // Expected format is `<header_key_1>: <header_value_1>, header_value_2>; <header_key_2>: <header_value_2>`
        // E.g., assetHeadersString Cloudflare-CDN-Cache-Control: max-age=2813308004; Cache-Tag: ABC123;
        EXPERIMENTAL_ASSET_HEADERS: parseStringFlag('EXPERIMENTAL_ASSET_HEADERS'),
        // Sets the timeout for SSR on lambda in ms
        SSR_TIMEOUT: parseStringFlag('SSR_TIMEOUT'),
        // Pushes the includedModules of each root component bundle into clientBootstrapConfig.preloadModules
        PRELOAD_INCLUDED_MODULES: parseBooleanFlag('PRELOAD_INCLUDED_MODULES'),
    };
}
/**
 * Helper function to parse boolean environment variables.
 * Returns true if the variable is set to 'true', false otherwise.
 */
function parseBooleanFlag(flag) {
    return process.env[flag]?.toLowerCase() === 'true' || false;
}
/**
 * Helper function to parse string environment variables.
 * Returns the trimmed string if the variable is defined, otherwise returns undefined.
 */
function parseStringFlag(flag) {
    const value = process.env[flag]?.trim();
    return value || undefined;
}
/**
 * Helper function to parse the LWR_TRACING flag.
 * Returns the value if it's not 'off' and is defined, otherwise returns false.
 */
function parseTracingFlag() {
    const tracingValue = process.env.LWR_TRACING?.toLowerCase();
    return tracingValue && tracingValue !== 'off' ? process.env.LWR_TRACING : undefined;
}
/**
 * This function is used to determine if the current environment is a lambda.
 *
 * @returns true if process is running in lambda environment
 */
export function isLambdaEnv() {
    return process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined;
}
/**
 * This function is used to determine if lwr is running in the context of local development.
 *
 * @returns true if running in localdev mode
 */
export function isLocalDev() {
    // TODO still need to formalize environment variable names
    return process.env.MRT_HMR === 'true';
}
/**
 * This function is used to determine if lwr is running in the context of local preview.
 *
 * @returns true if running in preview mode
 */
export function isLocalPreview() {
    return process.env.LOCAL_PREVIEW_MODE === 'true';
}
/**
 * This function is used to determine if lwr is running with an authenticated context locally
 *
 * @returns true if local dev/preview authentication is enabled
 */
export function isLocalAuthEnabled() {
    return process.env.AUTH_TOKEN !== undefined;
}
/**
 * Create a serializable context for user-land exposed environment variables
 */
export function buildEnvironmentContext(runtimeParams) {
    // The baseBath from the config or set from the request (e.g. /shop)
    const basePath = runtimeParams.basePath;
    // The locale set from the request or the defaultLocale from the config (e.g. en-US)
    const locale = runtimeParams.locale;
    // Root base path for static assets (e.g. /shop/mobify/bundle/1234/site)
    const assetBasePath = runtimeParams.assetBasePath;
    // Base path for UI routing (e.g. /shop/en-US)
    const uiBasePath = runtimeParams.uiBasePath;
    return {
        basePath,
        locale,
        assetBasePath,
        uiBasePath,
    };
}
// headers used by LWR-Node and LWR@MRT
export const TRUE_CLIENT_IP = 'true-client-ip'; // public IP of the original request source, eg: 13.123.12.3
export const CORRELATION_ID = 'x-correlation-id'; // shared correlation ID for the request
export const B3_TRACE_ID = 'x-b3-traceid'; // trace ID shared across service boundaries for a page request, set to inbound B3 header || lwr.handle.view trace ID
export const B3_SPAN_ID = 'x-b3-spanid'; // span ID for a trace
export const B3_PARENT_ID = 'x-b3-parentspanid'; // parent span ID for a trace
export const B3_SAMPLED = 'x-b3-sampled'; // "0" = tracing is off, "1" = tracing is on
export const MRT_REQUEST_CLASS = 'x-mobify-request-class'; // contains the site base path, eg: basePath=/mysite
export const ROUTE_CORE_HEADER = 'x-sfdc-route-core'; // helps route requests to Core efficiently, value: true
export const REQUEST_DEPTH_HEADER = 'x-sfdc-request-depth'; // tracks the request depth to prevent cycles to the LWR server, eg: 2
// standard headers: Forwarded (eg: host=dev.testing.com;proto=https), Host (eg: darrell.sandbox.my.site.com), Cookie (holds the SID for auth'ed requests)
export function parseRequestDepth(headers = {}, query = {}) {
    let maxDepth = 0;
    const value = headers && headers[REQUEST_DEPTH_HEADER];
    if (value) {
        if (Array.isArray(value)) {
            for (const depth of value) {
                if (typeof depth === 'string') {
                    const depthValue = parseInt(depth, 10);
                    if (!isNaN(depthValue) && depthValue > maxDepth) {
                        maxDepth = depthValue;
                    }
                }
            }
        }
        else if (typeof value === 'string') {
            const depth = parseInt(value, 10);
            if (!isNaN(depth) && depth > maxDepth) {
                maxDepth = depth;
            }
        }
    }
    if (query[REQUEST_DEPTH_HEADER]) {
        const queryValue = parseInt(query[REQUEST_DEPTH_HEADER], 10);
        if (!isNaN(queryValue) && queryValue > maxDepth) {
            maxDepth = queryValue;
        }
    }
    return maxDepth;
}
export function getTraceHeaders(runtimeParams, span) {
    const headers = {};
    if (runtimeParams.trueClientIP)
        headers[TRUE_CLIENT_IP] = runtimeParams.trueClientIP;
    if (runtimeParams.correlationID)
        headers[CORRELATION_ID] = runtimeParams.correlationID;
    if (!getFeatureFlags().DISABLE_B3_TRACING) {
        if (span?.traceId) {
            headers[B3_TRACE_ID] = span.traceId;
            headers[B3_SAMPLED] = parseTracingFlag() ? '1' : '0';
        }
        if (span?.spanId)
            headers[B3_SPAN_ID] = span.spanId;
        if (span?.parentSpanId)
            headers[B3_PARENT_ID] = span.parentSpanId;
    }
    return headers;
}
//# sourceMappingURL=env.js.map