<template>
    <div class="m-auto body-text">
        <h1>Case Creation API Integration</h1>
        <div class="code-textarea">
            <p>
                Task: Your company would like to leverage Salesforce to respond to customer support
                cases and they would like you to create a custom API that will create a Case record in
                Salesforce. This API will be used in web, as well as in their Android and iOS applications.
                Expose a REST Resource class that can be used by engineering to support this use case.
            </p>
            <ul>
                    <li>Origin can be either "web" or "mobile"</li>
                    <li>Build a Client Credentials Authentication flow</li>
                    <li>Status will be "New"</li>
                    <li>The payload request you can expect is below:</li>
            </ul>
            <span>{data}</span>
        </div>
        <h1>Initial Thoughts</h1>
        <p>
            The first consideration is if a custom API is necessary and whether we can we direct the engineering team to use the standard existing services 
            sObject APIs <a href="https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/resources_sobject_basic_info_post.htm"> (LINK)</a>. This 
            would allow the team to insert Cases without us needing to build them a custom api, which would save a good amount of team effort. Through the auth process
            and integration user we would be able to limit their access. The challenge is that the requirements of enforcing that the Origin is either "web" 
            or "mobile" would prove challenging. We could enfore this in a validation rule, before save flow, apex etc. However we do not want to enfore this 
            requirement every time a Case is created. One "workaround" is we could create a checkbox field and ask the engineering team to set it to true on 
            insert. With this we could check the Origin conditions and when the checkbox isn't set, we'd ignore it. However, that is bit of a janky workaround and
            for the purposes of this exercise we will assume that we want this as foolproof as possible and that that is not an option.
        </p>
        <h1>What We Will Build</h1>
        <p>
            This leaves us with the option of creating a custom REST resource for the engineering team to call. Our first and biggest consideration is security as we will
            be providing an external team with access to our system. So our goal will be to provide the bare minimum amount of access for the team to accomplish their
            goal of inserting a Case. The second consideration will be building a comprehensive stable endpoint that handles edge scenarios elegantly and gives the team
            calling the API the information they need to correct any issues with their request payload.
            A rough outline of the items we will need to implement are as follows:
        </p>
        <ul>
            <li>An authentication flow</li>
            <li>A user</li>
            <li>an Apex class</li>
            <li>a easy way to test the API</li>
        </ul>
        <h2>Authentication Flow</h2>
        <p>
            the task scope outlines using a Client Credentials flow. The gold standard for Oauth2.0 authentication flows is the JWT Bearer Flow, however sometimes
            the external system cannot support this flow, so a Client Credentials flow is the second most secure choice. Below is an outline of the flow:
        </p>
        <img class="client-credentials" src="public/assets/Client-Credentials.png" alt="client creds"/>
        </br>
        <example-magic-link link="https://blog.beyondthecloud.dev/blog/salesforce-oauth-2-0-flows-integrate-in-the-right-way" label="Source"></example-magic-link>
        <p>
            the basic structure is that the calling system will hold a Client Id and Client Secret that it will utilize the call the Salesforce. The system
            will pass back an auth token if the Client Id and Client Secret are valid. The calling system will then use that auth token to do an action, in this situation
            call an endpoint. On the Salesforce end we will need to create a Connected App, which will produce the Client Id and Client Secret for the external team. 
        </p>
        <h3>Connected App</h3>
        <p>
            How we structure our connected app will be critical in keeping with our original goal of least access possible. The first step towards doing that will be 
            correctly choosing the scope of the Connected App. For our given scenario, the best choice is the Manage user data via APIs. This will still allow Case creation
            but limit the external client to only accessing Salesforces APIs. 
        </p>
        <img class="client-credentials" src="public/assets/connected-app-settings.png" alt="client creds"/>
        <p>
            However, our system might have multiple APIs and the standard sObject APIs are also quite powerful. So we will need a way to further reduce the access that the 
            calling system will have. We can do this using an specific integration user that we will create. Any operation the external client does after authenticating to
            our Connected App will be done as this user.
        </p>
        <img class="integration-user" src="public/assets/integration-user.png" alt="client creds"/>
        <h3>Integration User</h3>
        <p>
            When creating this user (or any user), we'll need to consider the license and profile. Salesforce has fortunately created a license specifically for integration
            users named the "Salesforce Integration" license. This is a low cost alternative to a full license. The Profile options for this license are limited and for our
            use case (creating a record) the "Minimum Access â€“ API Only Integrations" fits our scenario. This will not allow anything other than API access to the system. We
            will need to open up a few permissions and we can do that with the flexibility of Permission Sets. We can provide access to the fields that will be set upon insertion
            as well as give Read and Edit access to Case.
        </p>
        <img class="client-credentials" src="public/assets/permission-set.png"/>
        <h2>REST Endpoint</h2>
        <p>
            Now that we have the authentication piece all set, we can move towards creating a custom REST endpoint for the external team to call. We will create an apex class
            with the Rest Resource annotation of @RestResource(urlMapping='/CreateSupportCase'). This apex class will handle Post calls as this scenario is modifying/creating
            data. Some goals that we have for our code are as follows:
        </p>
         <ul>
            <li>Enforce the outlined Request structure</li>
            <li>Handle any malformed requests</li>
            <li>Enfore an origin of "web" or "mobile"</li>
            <li>Give back clear error messaging to the calling system</li>
        </ul>
        <p>
            We can accomplish this with a few patterns. The first of which is our exception pattern. We create a custom exception within the class so 
            that we can include specific information when we throw the exception, like the ResponseInfo class (more on that later)
        </p>
        <img class="client-credentials" src="public/assets/custom-exception.png"/>
        <p>
            We will wrap all of the code that will run during API execution context in a Try / Catch. In addition to catching our custom exception it allows
            us to handle unexpected exceptions but still format the response in the same way every time so the calling system knows what to expect.
        </p>
        <img class="client-credentials" src="public/assets/try-catch.png"/>
        <p>
            This also allows us to effectively stop the execution from anywhere in the code by throwing our custom exception with the necessary information. 
            When a structure like this is not implemented, it makes it very difficult when an issue is detected to stop the execution and return a response up the
            chain of methods. It typically leads to all code being written in one method as returning relevent info from a child method is challenging.
        </p>
        <p>
            Within the try /catch, the catch statement identifies if it is our custom exception and if not, creates a custom exception with the information from the
            error so that our setErrorResponse() method knows what information will be present and can build our response.
        </p>
        <p>
            The beauty of this pattern is in the ResponseInfo methods sitting near the top of the class. 
        </p>
        <img class="client-credentials" src="public/assets/response-info.png"/>
        <p>
            These effectively become documentation for every possible response that we will return. These methods are clearly named and have a response code (ie. 201, 400 etc.),
            a string response code and an error message. This makes it very easy to add new ResponseInfos, reuse them and see what part of the code threw them.
        </p>
        <p>
            An example usage is the check for the correct origin value. After parsing the response with our inner Request class, we'll pass the Origin value to this method, which
            will check if it is valid. if it is not, it will throw a custom exception with a ResponseInfo object. The error message will be dynamic, including the value they attempted
            to pass in so they can easily understand what the expectation is vs. what they provided.
        </p>
        <img class="client-credentials" src="public/assets/origin-check.png"/>
        <h2>Testing</h2>
        <p>
            The first aspect of testing that we'll need to complete is an Apex test class. The most critical piece that I often see missed in integration testing is
            testing as the Integration user (or a user who reflects all the permissions the integration user has). If the apex test class isn't running in context as
            that integration user, it will run as the running executing the test class, who will likely have vastly different permissions. The rest of the tests are
            straightforward, we want to test positive scenarios as well as negative scenarios and ensure we are Asserting 
        </p>
        <img class="client-credentials" src="public/assets/test-class.png"/>
        <p> 
            The next step is setting up some type of ability to manually call the API. In the <a href="https://github.com/Bobbygllh/CreateCaseAPI/blob/main/README.md">ReadME </a>
            I detail how to use a powerful VS Code tool called RestClient Extension to call the endpoint. Having an easy way to modify the Request and test the API
            allows for a quick way to recreate the issue if the calling team is running into a problem. 
        </p>
    </div>
    
</template>