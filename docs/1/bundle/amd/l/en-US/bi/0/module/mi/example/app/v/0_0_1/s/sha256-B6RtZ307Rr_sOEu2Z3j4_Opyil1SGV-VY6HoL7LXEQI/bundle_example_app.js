LWR.define("example/lwcBP/v/0_0_1",["exports","lwc/v/8_22_4","example/sharedStyles/v/0_0_1"],function(a,t,f){"use strict";function h(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var w=h(f);function n(e,p,x){var d=e?"["+e+"]":"";return".client-credentials"+d+" {width: 80%}.integration-user"+d+" {width: 90%}"}var s=[w.default,n];const v=t.parseFragment`<div class="m-auto body-text${0}"${2}><h1${3}>Case Creation API Integration</h1><div class="code-textarea${0}"${2}><p${3}>Task: Your company would like to leverage Salesforce to respond to customer support cases and they would like you to create a custom API that will create a Case record in Salesforce. This API will be used in web, as well as in their Android and iOS applications. Expose a REST Resource class that can be used by engineering to support this use case.</p><ul${3}><li${3}>Origin can be either &quot;web&quot; or &quot;mobile&quot;</li><li${3}>Build a Client Credentials Authentication flow</li><li${3}>Status will be &quot;New&quot;</li><li${3}>The payload request you can expect is below:</li></ul><span${3}>${"t16"}</span></div><h1${3}>Initial Thoughts</h1><p${3}>The first consideration is if a custom API is necessary and whether we can we direct the engineering team to use the standard existing services sObject APIs <a href="https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/resources_sobject_basic_info_post.htm"${3}> (LINK)</a>. This would allow the team to insert Cases without us needing to build them a custom api, which would save a good amount of team effort. We could create an API user with Case only privileges which would limit their access. The challenge is that the requirements of enforcing that the Origin is either &quot;web&quot; or &quot;mobile&quot; would prove challenging. We could enfore this in a validation rule, before save flow, apex etc. However we do not want to enfore this requirement every time a Case is created. One &quot;workaround&quot; is we could create a checkbox field and ask the engineering team to set it to true on insert. For the purposes of this excersize we will assume that we want this as foolproof as possible and that that is not an option.</p><h1${3}>What We Will Build</h1><p${3}>This leaves us with the option of creating a custom REST resource for the engineering team to call. Our first and biggest considerations is security as we will be providing an external team with access to our system. So our goal will be to provide the bare minimum amount of access for the team to accomplish their goal of inserting a Case. The second consideration will be building a comprehensive stable endpoint that handles edge scenarios elegantly and gives the team calling the API the information they need to correct any issues with their request payload. A rough outline of the items we will need to implement are as follows:</p><ul${3}><li${3}>An authentication flow</li><li${3}>A user</li><li${3}>an Apex class</li><li${3}>a easy way to test the API</li></ul><h2${3}>Authentication Flow</h2><p${3}>the task scope outlines using a Client Credentials flow. The gold standard for Oauth2.0 authentication flows is the JWT Bearer Flow, however sometimes the external system cannot support this flow, so a Client Credentials flow is the second most secure choice. Below is an outline of the flow:</p><img class="client-credentials${0}" src="/public/assets/Client-Credentials.png" alt="client creds"${2}><span${3}><a href="https://blog.beyondthecloud.dev/blog/salesforce-oauth-2-0-flows-integrate-in-the-right-way"${3}>Source</a></span><p${3}>the basic structure is that the calling system will hold a Client Id and Client Secret that it will utilize the call the Salesforce system. The system will pass back an auth token if the Client Id and Client Secret are valid. The calling system will then use that auth token to do an action, in this situation call an endpoint. On the Salesforce end we will need to create a Connected App, which will produce the Client Id and Client Secret for the external team.</p><h3${3}>Connected App</h3><p${3}>How we structure our connected app will be critical in keeping with our original goal of least access possible. The first step towards doing that will be correctly choosing the scope of the Connected App. For our given scenario, the best choice is the Manage user data via APIs. This will still allow Case creation but limit the external client to only accessing Salesforces APIs.</p><img class="client-credentials${0}" src="/public/assets/connected-app-settings.png" alt="client creds"${2}><p${3}>However, our system might have multiple APIs and the standard sObject APIs are also quite powerful. So we will need a way to further reduce the access that the calling system will have. We can do this using an specific integration user that we will create. Any operation the external client does after authenticating to our Connected App will be done as this user.</p><img class="integration-user${0}" src="/public/assets/integration-user.png" alt="client creds"${2}><h3${3}>Integration User</h3><p${3}>When creating this user (or any user), we&#x27;ll need to consider the license and profile. Salesforce has fortunately created a license specifically for integration users named the &quot;Salesforce Integration&quot; license. This is a low cost alternative to a full license. The Profile options for this license are limited and for our use case (creating a record) the &quot;Minimum Access â€“ API Only Integrations&quot; fits our scenario. This will not allow anything other than API access to the system. We will need to open up a few permissions and we can do that with the flexibility of Permission Sets. We can provide access to the fields that will be set upon insertion as well as give Read and Edit access to Case.</p><img class="client-credentials${0}" src="/public/assets/permission-set.png"${2}><h2${3}>REST Endpoint</h2><p${3}>Now that we have the authentication piece all set, we can move towards creating a custom REST endpoint for the external team to call. We will create an apex class with the Rest Resource annotation of @RestResource(urlMapping=&#x27;/CreateSupportCase&#x27;). This apex class will handle Post calls as this scenario is modifying/creating data. Some goals that we have for our code are as follows:</p><ul${3}><li${3}>Enforce the outlined Request structure</li><li${3}>Handle any malformed requests</li><li${3}>Enfore an origin of &quot;web&quot; or &quot;mobile&quot;</li><li${3}>Give back clear error messaging to the calling system</li></ul><p${3}>We can accomplish this with a few patterns. The first of which is our exception pattern. We create a custom exception within the class so that we can include specific information when we throw the exception, like the ResponseInfo class (more on that later)</p><img class="client-credentials${0}" src="/public/assets/custom-exception.png"${2}><p${3}>We will wrap all of the code that will run during API execution context in a Try / Catch. In addition to catching our custom exception it allows us to handle unexpected exceptions but still format the response in the same way every time so the calling system knows what to expect.</p><img class="client-credentials${0}" src="/public/assets/try-catch.png"${2}><p${3}>This also allows us to effectively stop the execution from anywhere in the code by throwing our custom exception with the necessary information. When a structure like this is not implemented, it makes it very difficult when an issue is detected to stop the execution and return a response up the chain of methods. It typically leads to all code being written in one method as returning relevent info from a child method is challenging.</p><p${3}>Within the try /catch, the catch statement identifies if it is our custom exception and if not, creates a custom exception with the information from the error so that our setErrorResponse() method knows what information will be present and can build our response.</p><p${3}>The beauty of this pattern is in the ResponseInfo methods sitting near the top of the class.</p><img class="client-credentials${0}" src="/public/assets/response-info.png"${2}><p${3}>These effectively become documentation for every possible response that we will return. These methods are clearly named and have a response code (ie. 201, 400 etc.), a string response code and an error message. This makes it very easy to add new ResponseInfos, reuse them and see what part of the code threw them.</p><p${3}>An example usage is the check for the correct origin value. After parsing the response with our inner Request class, we&#x27;ll pass the Origin value to this method, which will check if it is valid. if it is not, it will throw a custom exception with a ResponseInfo object. The error message will be dynamic, including the value they attempted to pass in so they can easily understand what the expectation is vs. what they provided.</p><img class="client-credentials${0}" src="/public/assets/origin-check.png"${2}><h2${3}>Testing</h2><p${3}>The first aspect of testing that we&#x27;ll need to complete is an Apex test class. The most critical piece that I often see missed in integration testing is testing as the Integration user (or a user who reflects all the permissions the integration user has). If the apex test class isn&#x27;t running in context as that integration user, it will run as the running executing the test class, who will likely have vastly different permissions. The rest of the tests are straightforward, we want to test positive scenarios as well as negative scenarios and ensure we are Asserting</p><img class="client-credentials${0}" src="/public/assets/test-class.png"${2}><p${3}>The next step is setting up some type of ability to manually call the API. In the <a href="https://github.com/Bobbygllh/CreateCaseAPI/blob/main/README.md"${3}>ReadME </a>I detail how to use a powerful VS Code tool called RestClient Extension to call the endpoint. Having an easy way to modify the Request and test the API allows for a quick way to recreate the issue if the calling team is running into a problem.</p></div>`;function i(e,p,x,d){const{d:m,sp:u,st:_}=e;return[_(v,1,[u(16,null,m(p.data))])]}var g=t.registerTemplate(i);i.stylesheets=[],i.stylesheetToken="lwc-3krbtcrj7lg",i.legacyStylesheetToken="example-lwcBP_lwcBP",s&&i.stylesheets.push.apply(i.stylesheets,s),t.freezeTemplate(i);class l extends t.LightningElement{constructor(...p){super(...p);this.data=`{
        subject: "Subject",
        description: "Description",
        status: "Status",
        origin: "Origin",
        name: "SuppliedName",
        phone: "SuppliedPhone",
        email: "SuppliedEmail"
}`}}t.registerDecorators(l,{fields:["data"]});const $=t.registerComponent(l,{tmpl:g,sel:"example-lwc-bp",apiVersion:66});a.default=$,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/apexBP/v/0_0_1",["exports","lwc/v/8_22_4","example/sharedStyles/v/0_0_1"],function(a,t,f){"use strict";function h(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var w=h(f);function n(e,p,x){var d=e?"["+e+"]":"";return".client-credentials"+d+" {width: 80%}.integration-user"+d+" {width: 90%}"}var s=[w.default,n];const v=t.parseFragment`<div class="m-auto body-text${0}"${2}><h1${3}>Apex Best Practices</h1><h3${3}>Check if Object/variables are null before accessing to avoid Null Pointer exceptions</h3><p${3}>Null pointer exceptions are thrown when trying to access/use an object reference or variable which has a null value or is not initialized. Often code that could potentially throw a NullPointerException error isn&#x27;t within try/catch blocks like DML statements, so the error will reach the user or roll back the process entirely. We need to check whether an object or variable is null before we run a method upon it (like get or toString etc. etc.) There are two ways we can do so, utilizing the safe navigation operator or a simple if statement if(object!= null). The preferred method would be the safe navigation operator as it allows for cleaner, more readable code. For example, instead of the following:</p><img class="client-credentials${0}" src="/public/assets/1apex.png" alt="client creds"${2}><p${3}>We could rewrite it as below utilizing the safe navigation operator. Putting ? before the get method means that if the retrieveRecordTypesByDeveloperName() method returns null then running .get() won&#x27;t produce a null pointer exception. Without the safe navigation operator (or a if null check to ensure its defined) then a Null Pointer Exception would be thrown</p><img class="client-credentials${0}" src="/public/assets/2apex.png" alt="client creds"${2}><p${3}>This is particularly effective in accessing multilevel maps like sampleMap. Instead of long or multiline if statement checks (ie. first screenshot x3) we can just write sampleMap?.getidVariable()?.getidVariable()?.get(idVariable). However if it is preferred to use code like the first screenshot, that is acceptable as well.</p><h3${3}>Avoid Triple Looping</h3><p${3}>For general performance we generally want to reduce the amount of for loops running in our code. If we can loop over a set of records once instead of twice during a codes execution that is preferable. However what we want to explicitly avoid is triple looping. This significantly eats up CPU time and causes our operations to take longer than they need to. An example of triple looping is the below:</p><img class="client-credentials${0}" src="/public/assets/3apex.png" alt="client creds"${2}><h3${3}>Handle Potential Exceptions in Try/Catch blocks</h3><p${3}>Correctly handling exceptions in Apex is essential, unhandled errors will roll back the code execution and make it more difficult to debug issues.</p><ul${3}><li${3}>Correctly handling exceptions in Apex is essential, unhandled errors will roll back the code execution and make it more difficult to debug issues.</li><li${3}>Exception Class</li></ul><strong${3}>DO</strong><p${3}>Handle frequently errored processes (web callouts/ DML statements) in Try Catch blocks and log errors to the exception table. That way we don&#x27;t need to have users recreate errors live</p><strong${3}>DO</strong><p${3}>Stack multiple catch statements if you need to handle errors in different ways</p><img class="client-credentials${0}" src="/public/assets/4apex.png" alt="client creds"${2}><br${3}><strong${3}>DON&#x27;T</strong><p${3}>Wrap entire large pieces of code into Try/Catch blocks and then catch it with only a generic exception. This will often suppress errors generated from code that is not functioning properly.</p><strong${3}>DON&#x27;T</strong><p${3}>Have an empty catch statement or a catch statement that just System.debugs the code. This will make debugging nearly impossible as we&#x27;re entirely suppressing errors</p><img class="client-credentials${0}" src="/public/assets/5apex.png" alt="client creds"${2}><h3${3}>Don&#x27;t write code in Apex Triggers</h3><p${3}>There are a couple currently existing Apex triggers which contain code but going forward we should not be writing new Apex Triggers other than generic handler classes. A good example of a trigger containing business logic is CaseToAlfa, preferably that logic would be called by CaseTriggerHandler. By utilizing a Trigger handler we can determine in what order the code runs and maintain our system of organization.</p><img class="client-credentials${0}" src="/public/assets/6apex.png" alt="client creds"${2}><h3${3}>Use curly braces for if statements/For Loops</h3><p${3}>An age old debate but there is a lot of code in the code base which does not utilize curly braces following if or for statements/loops. The argument for curly braces is it reduces potential mistakes or confusion from developers maintaining the codebase. No curly braces even caused a very notable Apple bug. Here is a screenshot from stackoverflow outlining the potential for confusion caused by no curly braces:</p><img class="client-credentials${0}" src="/public/assets/Client-Credentials.png" alt="client creds"${2}><p${3}>this example from the codebase shows how reading mixed curly braces/no curly braces is confusing</p><img class="client-credentials${0}" src="/public/assets/7apex.png" alt="client creds"${2}><br${3}><strong${3}>DO</strong><p${3}>no ambiguity, easier to read</p><img class="client-credentials${0}" src="/public/assets/8apex.png" alt="client creds"${2}><h3${3}>Cover all testing scenarios with System.assert methods</h3><ul${3}><li${3}>The minimum requirement from Salesforce is that Test classes have 75% code coverage to be released into Production. However we want to ensure that our classes actually do what the are intended to do, not just that the code runs. So we need to ensure they test the code in 3 essential ways:</li><li${3}>Scenario: The business asks that if a user enters/modifies the Phone field on a Contact record that the entered value is formatted to (123) 456-7891 unless it is less or more than 9 numbers, in that situation it should not be formatted</li><ul${3}><li${3}>Positive Scenario: Test that the code does what you expect it to do. -ie. 1234567891 should be updated to (123) 456-7891</li><li${3}>Negative Scenario: Test that the code does not behave in a way we don&#x27;t want it to - ie. 123456 should stay as 123456, not be updated to (123) 456- (or something similar)</li><li${3}>Bulk Scenario: insert/update multiple records at once to ensure that the code performs as expected in bulk update/inserts - Insert a list of contacts with the Phone field filled in, check that each record is formatted as expected</li></ul><li${3}>To check that all these scenarios work as expected we need to utilize System.Assert. Every single test method you write should have some type of System.assert method in it</li></ul></div>`;function i(e,p,x,d){const{st:m}=e;return[m(v,1)]}var g=t.registerTemplate(i);i.stylesheets=[],i.stylesheetToken="lwc-ajssbuvofl",i.legacyStylesheetToken="-apexBP_apexBP",s&&i.stylesheets.push.apply(i.stylesheets,s),t.freezeTemplate(i);class l extends t.LightningElement{constructor(...p){super(...p);this.data=`{
        subject: "Subject",
        description: "Description",
        status: "Status",
        origin: "Origin",
        name: "SuppliedName",
        phone: "SuppliedPhone",
        email: "SuppliedEmail"
}`}}t.registerDecorators(l,{fields:["data"]});const $=t.registerComponent(l,{tmpl:g,sel:"example-apex-bp",apiVersion:66});a.default=$,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/blogs/v/0_0_1",["exports","lwc/v/8_22_4","example/sharedStyles/v/0_0_1","example/apexBP/v/0_0_1","example/lwcBP/v/0_0_1"],function(a,t,f,h,w){"use strict";function n(o){return o&&typeof o=="object"&&"default"in o?o:{default:o}}var s=n(f),v=n(h),i=n(w);function g(o,c,r){var k=o?"["+o+"]":"";return".font-inherit"+k+" {color: inherit;}"}var l=[s.default,g];const $=t.parseFragment`<h1${3}>Blogs</h1>`,e=t.parseFragment`<a class="font-inherit flex items-center p-med-top${0}"${"a0:data-item"} href="#"${2}><div class="flex-auto${0}"${2}><div${3}>${"t3"}</div><div class="text-sm${0}"${2}>${"t5"}</div></div></a>`,p={classMap:{"m-auto":!0,"body-text":!0,"page-height":!0},key:1},x={key:4},d={key:8},m={key:10};function u(o,c,r,k){const{st:b,k:A,b:R,d:S,sp:T,i:C,h:j,fr:q,c:O}=o,{_m0:L,_m1:N}=k;return[c.isSelectionShown?q(0,[j("div",p,[b($,3),j("div",x,C(c.blogObjs,function(W){return b(e,A(6,W.lwcReference),[T(0,{on:N||(k._m1={click:R(c.handleNavigate)}),attrs:{"data-item":W.lwcReference}},null),T(3,null,S(W.title)),T(5,null,S(W.date))])}))])],0):null,c.renderLwcs.apexBP?q(7,[O("example-apex-b-p",v.default,d)],0):null,c.renderLwcs.lwcBP?q(9,[O("example-lwc-b-p",i.default,m)],0):null]}var _=t.registerTemplate(u);u.stylesheets=[],u.stylesheetToken="lwc-7v429e70suo",u.legacyStylesheetToken="-blogs_blogs",l&&u.stylesheets.push.apply(u.stylesheets,l),t.freezeTemplate(u);const P=[{title:"Apex Best Practices",date:"October 2025",lwcReference:"apexBP"},{title:"Lightning Web Component Best Practices",date:"October 2025",lwcReference:"lwcBP"}];class I extends t.LightningElement{constructor(...c){super(...c);this.blogObjs=P,this.isSelectionShown=!1,this.renderLwcs={apexBP:!1,lwcBP:!1},this.handleHistoryChange=r=>{console.log("Browser history state changed via popstate event.")}}reset(){this.isSelectionShown=!0}connectedCallback(){window.addEventListener("popstate",this.handleHistoryChange)}disconnectedCallback(){window.removeEventListener("popstate",this.handleHistoryChange)}connectedCallback(){this.isSelectionShown=!0}handleNavigate(c){const r=c.currentTarget.dataset.item;this.renderLwcs[r]=!0,this.isSelectionShown=!1}}t.registerDecorators(I,{publicMethods:["reset"],track:{renderLwcs:1},fields:["blogObjs","isSelectionShown","handleHistoryChange"]});const y=t.registerComponent(I,{tmpl:_,sel:"-blogs",apiVersion:66});a.default=y,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/lwcOssWebsite/v/0_0_1",["exports","lwc/v/8_22_4"],function(a,t){"use strict";const f=[];function h(v,i,g,l){return f}var w=t.registerTemplate(h);h.stylesheets=[],h.stylesheetToken="lwc-uq7jirsc85",h.legacyStylesheetToken="example-lwcOssWebsite_lwcOssWebsite",t.freezeTemplate(h);class n extends t.LightningElement{}const s=t.registerComponent(n,{tmpl:w,sel:"example-lwc-oss-website",apiVersion:66});a.default=s,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/caseApi/v/0_0_1",["exports","lwc/v/8_22_4","example/sharedStyles/v/0_0_1"],function(a,t,f){"use strict";function h(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var w=h(f);function n(e,p,x){var d=e?"["+e+"]":"";return".client-credentials"+d+" {width: 80%}.integration-user"+d+" {width: 90%}"}var s=[w.default,n];const v=t.parseFragment`<div class="m-auto body-text${0}"${2}><h1${3}>Case Creation API Integration</h1><div class="code-textarea${0}"${2}><p${3}>Task: Your company would like to leverage Salesforce to respond to customer support cases and they would like you to create a custom API that will create a Case record in Salesforce. This API will be used in web, as well as in their Android and iOS applications. Expose a REST Resource class that can be used by engineering to support this use case.</p><ul${3}><li${3}>Origin can be either &quot;web&quot; or &quot;mobile&quot;</li><li${3}>Build a Client Credentials Authentication flow</li><li${3}>Status will be &quot;New&quot;</li><li${3}>The payload request you can expect is below:</li></ul><span${3}>${"t16"}</span></div><h1${3}>Initial Thoughts</h1><p${3}>The first consideration is if a custom API is necessary and whether we can we direct the engineering team to use the standard existing services sObject APIs <a href="https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/resources_sobject_basic_info_post.htm"${3}> (LINK)</a>. This would allow the team to insert Cases without us needing to build them a custom api, which would save a good amount of team effort. We could create an API user with Case only privileges which would limit their access. The challenge is that the requirements of enforcing that the Origin is either &quot;web&quot; or &quot;mobile&quot; would prove challenging. We could enfore this in a validation rule, before save flow, apex etc. However we do not want to enfore this requirement every time a Case is created. One &quot;workaround&quot; is we could create a checkbox field and ask the engineering team to set it to true on insert. For the purposes of this excersize we will assume that we want this as foolproof as possible and that that is not an option.</p><h1${3}>What We Will Build</h1><p${3}>This leaves us with the option of creating a custom REST resource for the engineering team to call. Our first and biggest considerations is security as we will be providing an external team with access to our system. So our goal will be to provide the bare minimum amount of access for the team to accomplish their goal of inserting a Case. The second consideration will be building a comprehensive stable endpoint that handles edge scenarios elegantly and gives the team calling the API the information they need to correct any issues with their request payload. A rough outline of the items we will need to implement are as follows:</p><ul${3}><li${3}>An authentication flow</li><li${3}>A user</li><li${3}>an Apex class</li><li${3}>a easy way to test the API</li></ul><h2${3}>Authentication Flow</h2><p${3}>the task scope outlines using a Client Credentials flow. The gold standard for Oauth2.0 authentication flows is the JWT Bearer Flow, however sometimes the external system cannot support this flow, so a Client Credentials flow is the second most secure choice. Below is an outline of the flow:</p><img class="client-credentials${0}" src="/public/assets/Client-Credentials.png" alt="client creds"${2}><span${3}><a href="https://blog.beyondthecloud.dev/blog/salesforce-oauth-2-0-flows-integrate-in-the-right-way"${3}>Source</a></span><p${3}>the basic structure is that the calling system will hold a Client Id and Client Secret that it will utilize the call the Salesforce system. The system will pass back an auth token if the Client Id and Client Secret are valid. The calling system will then use that auth token to do an action, in this situation call an endpoint. On the Salesforce end we will need to create a Connected App, which will produce the Client Id and Client Secret for the external team.</p><h3${3}>Connected App</h3><p${3}>How we structure our connected app will be critical in keeping with our original goal of least access possible. The first step towards doing that will be correctly choosing the scope of the Connected App. For our given scenario, the best choice is the Manage user data via APIs. This will still allow Case creation but limit the external client to only accessing Salesforces APIs.</p><img class="client-credentials${0}" src="/public/assets/connected-app-settings.png" alt="client creds"${2}><p${3}>However, our system might have multiple APIs and the standard sObject APIs are also quite powerful. So we will need a way to further reduce the access that the calling system will have. We can do this using an specific integration user that we will create. Any operation the external client does after authenticating to our Connected App will be done as this user.</p><img class="integration-user${0}" src="/public/assets/integration-user.png" alt="client creds"${2}><h3${3}>Integration User</h3><p${3}>When creating this user (or any user), we&#x27;ll need to consider the license and profile. Salesforce has fortunately created a license specifically for integration users named the &quot;Salesforce Integration&quot; license. This is a low cost alternative to a full license. The Profile options for this license are limited and for our use case (creating a record) the &quot;Minimum Access â€“ API Only Integrations&quot; fits our scenario. This will not allow anything other than API access to the system. We will need to open up a few permissions and we can do that with the flexibility of Permission Sets. We can provide access to the fields that will be set upon insertion as well as give Read and Edit access to Case.</p><img class="client-credentials${0}" src="/public/assets/permission-set.png"${2}><h2${3}>REST Endpoint</h2><p${3}>Now that we have the authentication piece all set, we can move towards creating a custom REST endpoint for the external team to call. We will create an apex class with the Rest Resource annotation of @RestResource(urlMapping=&#x27;/CreateSupportCase&#x27;). This apex class will handle Post calls as this scenario is modifying/creating data. Some goals that we have for our code are as follows:</p><ul${3}><li${3}>Enforce the outlined Request structure</li><li${3}>Handle any malformed requests</li><li${3}>Enfore an origin of &quot;web&quot; or &quot;mobile&quot;</li><li${3}>Give back clear error messaging to the calling system</li></ul><p${3}>We can accomplish this with a few patterns. The first of which is our exception pattern. We create a custom exception within the class so that we can include specific information when we throw the exception, like the ResponseInfo class (more on that later)</p><img class="client-credentials${0}" src="/public/assets/custom-exception.png"${2}><p${3}>We will wrap all of the code that will run during API execution context in a Try / Catch. In addition to catching our custom exception it allows us to handle unexpected exceptions but still format the response in the same way every time so the calling system knows what to expect.</p><img class="client-credentials${0}" src="/public/assets/try-catch.png"${2}><p${3}>This also allows us to effectively stop the execution from anywhere in the code by throwing our custom exception with the necessary information. When a structure like this is not implemented, it makes it very difficult when an issue is detected to stop the execution and return a response up the chain of methods. It typically leads to all code being written in one method as returning relevent info from a child method is challenging.</p><p${3}>Within the try /catch, the catch statement identifies if it is our custom exception and if not, creates a custom exception with the information from the error so that our setErrorResponse() method knows what information will be present and can build our response.</p><p${3}>The beauty of this pattern is in the ResponseInfo methods sitting near the top of the class.</p><img class="client-credentials${0}" src="/public/assets/response-info.png"${2}><p${3}>These effectively become documentation for every possible response that we will return. These methods are clearly named and have a response code (ie. 201, 400 etc.), a string response code and an error message. This makes it very easy to add new ResponseInfos, reuse them and see what part of the code threw them.</p><p${3}>An example usage is the check for the correct origin value. After parsing the response with our inner Request class, we&#x27;ll pass the Origin value to this method, which will check if it is valid. if it is not, it will throw a custom exception with a ResponseInfo object. The error message will be dynamic, including the value they attempted to pass in so they can easily understand what the expectation is vs. what they provided.</p><img class="client-credentials${0}" src="/public/assets/origin-check.png"${2}><h2${3}>Testing</h2><p${3}>The first aspect of testing that we&#x27;ll need to complete is an Apex test class. The most critical piece that I often see missed in integration testing is testing as the Integration user (or a user who reflects all the permissions the integration user has). If the apex test class isn&#x27;t running in context as that integration user, it will run as the running executing the test class, who will likely have vastly different permissions. The rest of the tests are straightforward, we want to test positive scenarios as well as negative scenarios and ensure we are Asserting</p><img class="client-credentials${0}" src="/public/assets/test-class.png"${2}><p${3}>The next step is setting up some type of ability to manually call the API. In the <a href="https://github.com/Bobbygllh/CreateCaseAPI/blob/main/README.md"${3}>ReadME </a>I detail how to use a powerful VS Code tool called RestClient Extension to call the endpoint. Having an easy way to modify the Request and test the API allows for a quick way to recreate the issue if the calling team is running into a problem.</p></div>`;function i(e,p,x,d){const{d:m,sp:u,st:_}=e;return[_(v,1,[u(16,null,m(p.data))])]}var g=t.registerTemplate(i);i.stylesheets=[],i.stylesheetToken="lwc-1n8ko1nd92k",i.legacyStylesheetToken="-caseApi_caseApi",s&&i.stylesheets.push.apply(i.stylesheets,s),t.freezeTemplate(i);class l extends t.LightningElement{constructor(...p){super(...p);this.data=`{
        subject: "Subject",
        description: "Description",
        status: "Status",
        origin: "Origin",
        name: "SuppliedName",
        phone: "SuppliedPhone",
        email: "SuppliedEmail"
}`}}t.registerDecorators(l,{fields:["data"]});const $=t.registerComponent(l,{tmpl:g,sel:"-case-api",apiVersion:66});a.default=$,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/projects/v/0_0_1",["exports","lwc/v/8_22_4","example/sharedStyles/v/0_0_1","example/caseApi/v/0_0_1","example/lwcOssWebsite/v/0_0_1"],function(a,t,f,h,w){"use strict";function n(c){return c&&typeof c=="object"&&"default"in c?c:{default:c}}var s=n(f),v=n(h),i=n(w);function g(c,r,k){var b=c?"["+c+"]":"";return".project-image"+b+" {width: 20%;}a"+b+" {color: inherit;}.project-item"+b+" {background: transparent;font-size: 1.1rem;width: 350px;max-width: 100%;padding: 0.5rem 0.875rem 0.875rem;border-radius: 6px;}.project-detail-item"+b+" {transition: .2s all ease-out;text-decoration: none;border-bottom: none !important;opacity: .6;}.project-item:hover"+b+" {background: rgba(79, 79, 79, 0.067);}a.item:hover"+b+" {opacity: 1;}"}var l=[s.default,g];const $=t.parseFragment`<h1${3}>Projects</h1>`,e=t.parseFragment`<a class="project-item project-detail-item relative flex items-center${0}"${"a0:data-item"} href="#"${2}><img class="project-image pr-5${0}"${"a1:src"}${2}><div class="flex-auto${0}"${2}><div class="text-normal${0}"${2}>${"t4"}</div><div class="desc text-sm opacity-50 font-normal${0}"${2}>${"t6"}</div></div></a>`,p={classMap:{"m-auto":!0,"body-text":!0,"page-height":!0},key:1},x={key:4},d={key:8},m={key:10};function u(c,r,k,b){const{st:A,k:R,b:S,d:T,sp:C,i:j,h:q,fr:O,c:L}=c,{_m0:N,_m1:W}=b;return[r.isSelectionShown?O(0,[q("div",p,[A($,3),q("div",x,j(r.projectObjs,function(E){return A(e,R(6,E.lwcReference),[C(0,{on:W||(b._m1={click:S(r.handleNavigate)}),attrs:{"data-item":E.lwcReference}},null),C(1,{attrs:{src:E.image}},null),C(4,null,T(E.title)),C(6,null,T(E.description))])}))])],0):null,r.renderLwcs.caseApi?O(7,[L("example-case-api",v.default,d)],0):null,r.renderLwcs.lwcOSS?O(9,[L("example-lwc-oss-website",i.default,m)],0):null]}var _=t.registerTemplate(u);u.stylesheets=[],u.stylesheetToken="lwc-vrkj4vlmso",u.legacyStylesheetToken="-projects_projects",l&&u.stylesheets.push.apply(u.stylesheets,l),t.freezeTemplate(u);const P=[{title:"Inbound API Integration",description:"This project is the creation of a end to end custom REST inbound api that inserts a Case",image:"/public/assets/api-integration.webp",lwcReference:"caseApi"},{title:"Building a LWC OSS Website",description:"Walkthrough of building this personal website with Lightning Web Component OSS and Github Pages",image:"/public/assets/lwc.png",lwcReference:"lwcOSS"}],I={caseApi:!1,lwcOSS:!1};class y extends t.LightningElement{constructor(...r){super(...r);this.projectObjs=P,this.isSelectionShown=!1,this.renderLwcs=JSON.parse(JSON.stringify(I))}reset(){this.isSelectionShown=!0,this.renderLwcs=JSON.parse(JSON.stringify(I))}connectedCallback(){this.isSelectionShown=!0}handleNavigate(r){const k=r.currentTarget.dataset.item;this.renderLwcs[k]=!0,this.isSelectionShown=!1}}t.registerDecorators(y,{publicMethods:["reset"],track:{renderLwcs:1},fields:["projectObjs","isSelectionShown"]});const o=t.registerComponent(y,{tmpl:_,sel:"-projects",apiVersion:66});a.default=o,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/navigation/v/0_0_1",["exports","lwc/v/8_22_4"],function(a,t){"use strict";function f(g,l,$){var e=g?"["+g+"]":"";return".nav"+e+" {padding: 2rem;width: 100%;display: grid;grid-template-columns: auto max-content;box-sizing: border-box;}.nav"+e+" img"+e+" {margin-bottom: 0;}.nav"+e+" a"+e+" {cursor: pointer;text-decoration: none;color: inherit;transition: opacity 0.2s ease;opacity: 0.6;outline: none;font-size: 1.4em;}.nav"+e+" a:hover"+e+" {opacity: 1;text-decoration-color: inherit;}.nav"+e+" .right"+e+" {display: grid;grid-gap: 1.2rem;grid-auto-flow: column;justify-content: flex-end;}.nav"+e+" .left"+e+" {display: grid;grid-gap: 1.2rem;grid-auto-flow: column;padding-left: 6rem;}.nav"+e+" .right"+e+" > *"+e+" {margin: auto;}.github-image"+e+" {width: 9%;}.initials-image"+e+" {width: 15%;}"}var h=[f];const w=t.parseFragment`<header${3}><nav class="nav${0}"${2}><div class="left${0}"${2}><img class="initials-image${0}" src="/public/assets/bg.svg" alt="logo"${2}></div><div class="right${0}"${2}><a href="#" title="Home" data-item="mainpage"${3}><span${3}>Home</span></a><a href="#" title="Projects" data-item="projects"${3}><span${3}>Projects</span></a><a href="#" title="Blog" data-item="blogs"${3}><span${3}>Blog</span></a><a href="https://github.com/bobbygllh" target="_blank" title="Github" class="lt-md:hidden${0}"${2}><img class="github-image${0}" src="/public/assets/github-mark.png" alt="logo"${2}></a></div></nav></header>`;function n(g,l,$,e){const{b:p,sp:x,st:d}=g,{_m0:m,_m1:u,_m2:_}=e;return[d(w,1,[x(5,{on:m||(e._m0={click:p(l.handleNavItemClick)})},null),x(8,{on:u||(e._m1={click:p(l.handleNavItemClick)})},null),x(11,{on:_||(e._m2={click:p(l.handleNavItemClick)})},null)])]}var s=t.registerTemplate(n);n.stylesheets=[],n.stylesheetToken="lwc-5390kdmit7f",n.legacyStylesheetToken="-navigation_navigation",h&&n.stylesheets.push.apply(n.stylesheets,h),t.freezeTemplate(n);class v extends t.LightningElement{handleNavItemClick(l){const $=l.currentTarget.dataset.item;l.preventDefault(),this.dispatchEvent(new CustomEvent("categorychange",{detail:$,bubbles:!0}))}}const i=t.registerComponent(v,{tmpl:s,sel:"-navigation",apiVersion:66});a.default=i,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/sharedStyles/v/0_0_1",["exports"],function(a){"use strict";function t(h,w,n){var s=h?"["+h+"]":"";return".body-text"+s+" {font-size: 1.05rem;max-width: 45rem;line-height: 1.75;}.body-text"+s+" a"+s+" {font-weight: inherit;text-decoration: none;border-bottom: 1px solid rgba(125, 125, 125, .3);transition: border .3s ease-in-out}.body-text"+s+" a:hover"+s+" {border-bottom: 1px solid black;}.p-med-top"+s+" {padding-top: 1rem;}.p-left"+s+" {margin-left: .25rem;}.p-left-large"+s+" {margin-left: 4rem;}.m-auto"+s+" {margin: auto;}.items-center"+s+" {align-items: center;}.flex"+s+" {display: flex;}.flex-auto"+s+" {flex: 1 1 auto;}.pt-2"+s+", .pt2"+s+" {padding-top: .5rem;}.pr-5"+s+" {padding-right: 1.25rem;}.op50"+s+" {opacity: .5;}.font-400"+s+" {font-weight: 400;}.text-sm"+s+" {font-size: .875rem;line-height: 1.25rem;}.code-textarea"+s+" {width: 100%;background-color: #433c3c;color: #dcdcdc;font-family: 'Fira Code', 'Consolas', 'Courier New', monospace;font-size: 14px;line-height: 1.5;padding: 16px;border: 1px solid #333;border-radius: 8px;resize: vertical;overflow: auto;box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);caret-color: #00ff99;outline: none;}.page-height"+s+" {height: 1000px;}"}var f=[t];a.default=f,Object.defineProperty(a,"__esModule",{value:!0})}),LWR.define("example/app/v/0_0_1",["exports","lwc/v/8_22_4","example/sharedStyles/v/0_0_1","example/navigation/v/0_0_1","example/projects/v/0_0_1","example/blogs/v/0_0_1"],function(a,t,f,h,w,n){"use strict";function s(y){return y&&typeof y=="object"&&"default"in y?y:{default:y}}var v=s(f),i=s(h),g=s(w),l=s(n);function $(y,o,c){var r=y?"["+y+"]":"";return".markdown-magic-link"+r+" {display: inline-flex;align-items: center;background: #8882;transform: translateY(3px);line-height: 100%;color: var(--fg-light) !important;gap: .25rem;border-width: 0px !important;border-radius: .25rem;padding: .25rem .375rem;font-family: Roboto Condensed;transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-timing-function: cubic-bezier(.4, 0, .2, 1);transition-duration: .15s;}.markdown-magic-link:hover"+r+" {background: #8883;color: var(--fg) !important;}.markdown-magic-link-image"+r+" {display: inline-block;height: 1.1em;width: 1.1em;background-size: cover;background-repeat: no-repeat;background-position: center;border-radius: 2px;}.about-me-image"+r+" {width: 40%}"}var e=[v.default,$];const p=t.parseFragment`<div class="m-auto body-text${0}"${2}><h1${3}>Introduction</h1><p${3}>Hi! I&#x27;m Bobby Gallahue, a Technical Lead with 7 years of experiance specializing in working on complex systems. I am currently getting my Masters at Tufts University in Computer Science with a planned graduation date of fall 2027</p><p${3}>I am currently working at<a href="https://www.ally.com/" class="p-left markdown-magic-link${0}" target="_blank"${2}><span class="markdown-magic-link-image${0}" style="background-image: url(https://play-lh.googleusercontent.com/fWqKGby23VpE85tWtvLBfBAIvfch65lnfFF9NgFt-e_uQIoO_5lSOT6yipYNKkghcYs=w240-h480-rw);"${2}></span>Ally Bank</a></p><p${3}>With previous stops at<a href="https://www.linkedin.com/company/cervello/" class="p-left markdown-magic-link${0}" target="_blank"${2}><span class="markdown-magic-link-image${0}" style="background-image: url(https://media.glassdoor.com/sql/718914/cervello-squarelogo-1442564055673.png);"${2}></span>Cervello</a><span${3}> and </span><a href="https://www.fiarch.com/" class="p-left markdown-magic-link${0}" target="_blank"${2}><span class="markdown-magic-link-image${0}" style="background-image: url(https://media.licdn.com/dms/image/v2/D4E0BAQEaohaOrBW-CQ/company-logo_200_200/company-logo_200_200/0/1733775033094/financial_architects_partners_logo?e=1762992000&amp;v=beta&amp;t=TaP3E_mmX_WrQvChexbXNSJSm-y7iLWvwcOGpo-XH9E);"${2}></span>Financial Architect Partners</a></p><h3${3}>Background</h3><p${3}>I began to learn to code after a challenging experiencing finding an eye doctor. The websites I encountered contained little information on what insurance the doctors took or how much a basic checkup might cost. Although I had no coding experiece, I wanted to see if I could improve the process and built some sample websites. This ignited a love for coding and an eventual career change. My passion for building applications and making some small improvement peoples day to day lives has not waned and Iâ€™m excited to keep learning and building.</p><h3${3}>About Me</h3><p${3}>Outside of work I am a passionate skier, surfer and mountain biker and you can typically find me somewhere in the White Mountains, Green Mountains or Seacoast of New Hampshire</p><img class="about-me-image${0}" src="/public/assets/skiing.jpg" alt="logo"${2}><img class="about-me-image p-left-large${0}" src="/public/assets/surfing.jpg" alt="logo"${2}></div>`,x={styleDecls:[["background-image","url(https://i.imgur.com/w074t77.png)",!1]],key:0},d={key:1};function m(y,o,c,r){const{b:k,c:b,h:A,st:R,fr:S}=y,{_m0:T,_m1:C,_m2:j}=r;return[A("div",x,[A("header",d,[b("example-navigation",i.default,{key:2,on:T||(r._m0={categorychange:k(o.handleCategoryChange)})})]),o.navigationItems.mainpage.visible?S(3,[R(p,5)],0):null,o.navigationItems.projects.visible?S(6,[b("example-projects",g.default,{key:7,on:C||(r._m1={categorychange:k(o.handleCategoryChange)})})],0):null,o.navigationItems.blogs.visible?S(8,[b("example-blogs",l.default,{key:9,on:j||(r._m2={categorychange:k(o.handleCategoryChange)})})],0):null])]}var u=t.registerTemplate(m);m.stylesheets=[],m.stylesheetToken="lwc-4us9q5akfb0",m.legacyStylesheetToken="-app_app",e&&m.stylesheets.push.apply(m.stylesheets,e),t.freezeTemplate(m);const _={mainpage:{visible:!1,child:!1},blogs:{visible:!1,child:!1},projects:{visible:!1,child:!1}};class P extends t.LightningElement{constructor(...o){super(...o);this.currentNavigationItem="mainpage",this.navigationItems=_}connectedCallback(){this.navigationItems[this.currentNavigationItem].visible=!0}handleCategoryChange(o){o&&(this.template.querySelector("example-projects")?.reset(),this.template.querySelector("example-blogs")?.reset(),this.navigationItems[this.currentNavigationItem].visible=!1,this.currentNavigationItem=o.detail,this.navigationItems[this.currentNavigationItem].visible=!0)}}t.registerDecorators(P,{track:{navigationItems:1},fields:["currentNavigationItem"]});const I=t.registerComponent(P,{tmpl:u,sel:"example-app",apiVersion:66});a.default=I,Object.defineProperty(a,"__esModule",{value:!0})});
